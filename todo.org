# Development Notes and TODO list
# Date stamps are when the task was started
# Closed stamps are when it was completed

* TODO Version 0.2.0 [2/8]
- [X] Update to version of clojurescipt and Austin plugin
- [ ] Sound system
- [ ] Tile collision
- [ ] Map to Screen coords
- [ ] Text rendering component
- [-] Optimization
  - [ ] Batch render sprites
    Move sprites to a new display object group and render all at once
  - [ ] Reducers?
    Investigate translating the game state transformations of systems and components as one giant reduction
  - [X] core.async to run systems async when marked as async-able
    - This turned out to be a very slow idea since just about everything so far is cpu bound
- [ ] Game loop macro
- [X] Helper macros/functions for declaring the game state
  - [X] Initialize state
  - [X] Initialize components
  - [X] Initialize entities
    - Subscribe events
    - Init component state
* TODO Add a combat system for attacking between entities [10/12] <2015-11-28 Sat>
- [X] Combat system
- [X] Meta system [2/2]
  Dynamically add/remove/change the game state by listening to events on the :meta where the message implements the specs for :entity
  - [X] Add entity
  - [X] Remove entity
- [X] TTL system/component
  When the duration of an entity exceeds the counter, emit an event to remove itself from the game
- [X] Attack component [2/2]
  - [X] Attack throttling with configurable cooldowns
  - [X] Emit events to :meta to create an attack entity
- [X] Implement cleanup functions for components
- [X] Update animateable component to remove the sprite from the stage using a :cleanup-fn
- [X] Update collision system to take into account offset-x/y
  Increase the size of the hit box to where the entity will be next frame this will mean all area the entity will pass through will be included for collision detection
- [-] Add damage system and hitpoint component
  - [X] Emit damage events when colliding with an entity prefixed by "attack"
  - [X] Emit an action event when colliding with an attack
  - Update hitpoints
  - [X] If hitpoints falls to 0 then emit a message to show the destro animation then remove the entity
  - [ ] Invinsibility period (cooldown of when they can take damage next)
- [X] FIX collisions with invisible bounding boxes?
  - When eliminating some enemies, end up colliding with nothing
- [ ] FIX when sending out hit action event all enemy animations receive it?
  - CHECK FIRST: pixi reuses textures or frames
  - In animateable component:
    - It's getting stuck on :hit-up and won't revert back to :stand-down
      (when (= next-action :hit-up)
        (println "HIT UP" next-action current-animation-name))
    - Stack should have :stand-down in it, but only has :hit-up, this means that pushing the current action down the stack is not working
- [X] Determine if it's attack collision if there is a damage attribute instead of overloading the entity-id
- [X] FIX cooldown requires a full cycle before it allows an attack
* DONE Should be able to create a sprite without an animation component <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 16:04]
Doesn't make sense that currently you need to make an animation component for something that doesn't animate
- [X] Update render-sprite to check for a moveable state before attempting to set a position
  - This means a sprite does not require a moveable component either
- [X] Update mk-sprite! to optionally take a frame this will force the rendering
* DONE Decouple movement offset from the controllable component <2015-12-25 Fri>
CLOSED: [2015-12-25 Fri 21:38]
Make the move component figure out to what rate the entity should move (offset)
* DONE Certain actions should be in addition to movement <2015-12-25 Fri>
CLOSED: [2015-12-25 Fri 18:00]
i.e Moving in addition to certain attacks such as fireball and walking
* TODO Add position offset to text component to better position text around an entity
* DONE Add text with the damage taken when an entity gets hit <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 17:26]
- Show red text with the hit amount taken
- Fade out after a short duration
- Should follow the entity
* TODO FIX spear attack doesn't work unless pushing a direction key simultaneously
* DONE Text rendering to sprites <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 15:37]
- Move sprites to a separate place instead of component state?
  - This would eliminate the coupling of multiple components that need to alter the sprite from having to know about each other
  - Would not need to be animateable to have a position
- Should there be a sprite component, position component, animation component?
  - Sprite component would do all the altering at the same time on the sprite
  - Sprite would only need to read the position component, animation component to know what to do
- [X] Create a text component
  - Initial state takes some text
  - Must be created with a position component
  - Don't want a text-movement system
* TODO Use metadata to derive the boilerplate game state wiring
- Instead of manually specifying all of the attributes of a system/component/entity use meta data
- Example:
  - Component function has a component name of :foo:
    (defn cf {:component-name :foo} [] ...)
    (defn component-name [f] (:component-name (meta (var component-fn))))
    (component-name component-fn) => :foo
- You can include functions in metadata too so we could use that to introspect the component's name instead of hardcoding it, you would only need to require the component-fn which means the compiler will throw errors earlier
- Specify dependencies of components for the purpose of catching errors earlier such as depending on a component state that does not exist
- mk-component-fn can read the meta data and intelligently figure out what args to call the function with
  - Selected state ends up in the third argument to the component function (a hashmap)
  - This prevents having to write a function every time you want to read some other component-state, instead you could list it in the meta data
  - {:require-component-states [:moveable :collideable]}
  - {:subscriptions [:move :collision]}
  - Or with more sugar, a dsl for selecting state of the game/components etc
    {:require-state [[:game :stage] [:component :move] [:component :collision]]}
* TODO Add spinning to movement system
* DONE Add diagonal attack <2015-12-13 Sun>
CLOSED: [2015-12-27 Sun 13:11]
* TODO Batch all events at the system level? <2015-11-15 Sun>
- This resulted in really big gains when doing collision detection where each entity can create more than one event
- Batching events for the ai system brought much less improvement so there may be something inherent about the collision events that were more severe
- Would be nice to only deal with events at the component fn level
* TODO Optimize ev/get-subscribed-events <2015-11-15 Sun>
According to profiler it's really slow
* TODO Assets pipeline for asynchronously loading sounds/tiles/sprites/etc
- Provide a nice abstraction for declaring pipeline of functions for loading assets asynchronously so that it doesn't look like spaghetti
- Integrate that into the mk-game-state function to keep the whole thing declarative
* TODO Add example of audio to the demo
* TODO Gameloop macro to inline the entire program into one function block
- Read this somewhere that referencing a ton of functions all over the place is not good for performance or garbage collection
- Write a macro that explodes all code into one massive function
* TODO input->interaction is non-deterministic
FIX The output of the interaction hashmap is non-deterministic
because it is iterating through a hashmap where ordering is not
guaranteed. Need to iterate through only the accepted keycodes and
check if the input-state shows the key is "on". That way order is
controlled by the caller
* TODO Moveable component-fn calls get-component-state twice for every entity
According to the compiler, the move component requires multiple get-component-state calls
* TODO Move rate should be calculated by Moveable and should have component state
- Controllable should give the intended action based on user input i.e. :walk/run/attack :left/right etc
- Another component should interpret that into a new screen position
- Moveable needs to know if there is a collision before moving and intended position
- Collideable needs to know the intended position of the character

* TODO Function that generates all the animation declarations in each direction
* TODO Key combinations from input
* TODO Debug layer for spatial grid
Show grid lines with numbers based on the spatial grid of that frame
* TODO Add skip frames to animation declaration to control animation speed
* TODO Use transients for things that are going to be iterated over and only need a local mutable value.
Could work well for systems when iterating over them
* TODO Clean up tilemapping code
- [ ] Add tests
- [ ] Split up monster loops
* TODO Fix collision detection <2014-12-07 Sun>
It's not working due to broad collision detection not accounting for mass of entity and not factoring in intended movement

* TODO Tiles that are non-traversable <2014-11-30 Sun>
Implement a tile map that checks for locations of entities that are collidable and sends an event if they are going to collide
- [ ] Create a spatial grid based on the map location (offset based on the view port of the screen)
- [ ] Put all tile collidable entities into their coordinates
- [ ] Iterate over all occupied tiles
- [ ] If they will be on a non-traversable tile, emit a tile collision event

* TODO Optimizations <2014-11-29 Sat>
- Systems iterate over all entities that have the component and then each component function
- Try to batch all the changes to the game-state in one shot
- Try using the reducers library for zero allocation collection operations
- Update component state and emit events takes up a significant amount of time
  number of hashmap ops = number of systems * number of entities with component * number of functions * number of events
- Lots of analysis on clojurescript performance http://wagjo.github.io/benchmark-cljs/
- [-] Use custom types using (.-a my-map) instead of keywords should be 3x faster <2014-11-30 Sun>
  - What about a macro that replaces get-in, assoc-in, update-in?
    Would need to always use our version of it which is dumb
  - Implement protocols for the custom type so that all the clojure map functions work with it
  - Underlying data structure will be a js array
  - [ ] Remove usage of assoc-in
    ./chocolatier/engine/ces.cljs:29:  (assoc-in state [:scenes uid] system-ids))
    ./chocolatier/engine/ces.cljs:68:  (assoc-in state [:entities uid] component-ids))
    ./chocolatier/engine/ces.cljs:86:  (assoc-in state [:state component-id entity-id] val))
    ./chocolatier/engine/ces.cljs:173:    (assoc-in state [:components uid] {:fns wrapped-fns})))
    ./chocolatier/engine/ces.cljs:211:    (assoc-in state [:systems uid] system-fn)))
    ./chocolatier/engine/systems/collision.cljs:101:      (assoc-in state [:state :spatial-grid] grid))))
    ./chocolatier/engine/systems/events.cljs:71:  (assoc-in state [:state :events :queue] {}))
    ./chocolatier/engine/systems/events.cljs:76:  (assoc-in state [:state :events] {:queue {} :subscriptions {}}))
    ./chocolatier/engine/systems/input.cljs:48:  (assoc-in state [:game :input] @KEYBOARD-INPUT))
    ./chocolatier/engine/systems/tiles.cljs:42:    (assoc-in state [:state :tiles]
    ./chocolatier/engine/systems/tiles.cljs:53:    (assoc-in state [:state :tiles] tiles)))
    ./chocolatier/entities/enemy.cljs:28:        (assoc-in [:state :renderable uid] init-render-state)
    ./chocolatier/entities/player.cljs:27:          (assoc-in [:state :renderable uid] init-render-state)
  - [ ] Remove usage of get-in
    ./chocolatier/engine/ces.cljs:81:  (or (get-in state [:state component-id entity-id]) {}))
    ./chocolatier/engine/systems/events.cljs:36:  (let [subscriptions (get-in state [:state :events :subscriptions entity-id])
    ./chocolatier/engine/systems/events.cljs:37:        events (get-in state [:state :events :queue])]
    ./chocolatier/engine/systems/events.cljs:38:    (mapcat #(get-in events (if (seqable? %) % [%])) subscriptions)))
  - [ ] Remove usage of update-in
    ./chocolatier/engine/systems/events.cljs:31:  (update-in state [:state :events :subscriptions entity-id] conj selectors))
    ./chocolatier/engine/systems/events.cljs:61:    (update-in state (concat [:state :events :queue] selectors) conj event)))
  - This did not end up working because of the semantics of property access ".-" makes it impossible to construct at compile time without evaling symbols which means they can not be dynamically evalualted by putting thename of the key in a var for instance.
- [ ] Batch game state changes
  - After every system take all of the changes from component entities and events and make the update in one shot
  - Uses many assoc-in
  - Should components operate on all entities at the same time? That would allow a single assoc-in to the game state from the accumulated component state that could be reduced in

* TODO Use a context buffer instead of writing all to one canvas
- This should speed up the rendering of lots of sprites
- Example code
        function onLoad() {
            // init stats
            var stats = new Stats();
            stats.getDomElement().style.position = 'absolute';
            stats.getDomElement().style.left = '0px';
            stats.getDomElement().style.top = '0px';
            document.body.appendChild( stats.getDomElement() );
            setInterval( function () { stats.update(); }, 1000 / 60 );

            // cache dom elements
            canvas = document.getElementById('my_canvas');
            context = canvas.getContext('2d');
            width = canvas.width;
            height = canvas.height;
            shipImage = document.getElementById('ship');

            // create canvas buffer
            canvasBuffer = document.createElement('canvas');
            contextBuffer = canvasBuffer.getContext('2d');
            canvasBuffer.width = 100;
            canvasBuffer.height = 100;
            contextBuffer.translate(50, 50); // so we can rotate about the center point

            // create lookup table for trig functions
            angleIncrement = Math.PI / 12;
            lookupTable = [];
            for (var i = 0; i < 5000; i++) {
                lookupTable[i] = {
                    x: Math.cos(i) * width - 150,
                    y: Math.sin(i) * height - 150
                };
            }

            // kick off the loop
            window.setInterval(update, 16);
        }

        // this is called using a 16 ms interval
        function update() {

            // draw transformed ship image to a canvas buffer
            contextBuffer.clearRect(0, 0, 100, 100);
            contextBuffer.rotate(angleIncrement);
            contextBuffer.drawImage(shipImage, 0, 0, 50, 50);

            // draw 5,000 ships
            for (var i = 0; i < 5000; i++) {
                var lookup = lookupTable[i];
                context.drawImage(canvasBuffer, lookup.x, lookup.y);
            }
        }
* TODO Use AABBTree (Axis aligned Bounding Box Tree) for collision detection
* TODO Make the input system emit an event
Currently it updates it's component state but that's it. SHould send an event to avoid other components querying it directly

* TODO Change mk-component to also handle subscribing to events
* TODO Change mk-system to also register it with a scene id
* TODO Query-like functionality for state                              :core:
Send a query with what you want and a filter function
Returns a sequence
* TODO Reset the game height on screen resize                          :core:
* TODO Protection against overflowing messages
  Throw an error if two many messages are generated. This will prevent avalanches and fail faster so it is easier to diagnose problems.
  - [ ] Limit on number of messages in an inbox
  - [ ] Limit on number of messages in the event queue

* TODO Change 'state' to 'game' everywhere it is passed in as an argument
game -> :state is where the state lives, everything else is game related such as systems, components, platform, etc
* TODO Tests [2/3] <2014-10-04 Sat>
- [X] CES internals
- [ ] Input system/components
- [X] Event system

* TODO Re-implement fixed timestep loop
http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
* TODO During movement change the players map position <2014-03-23 Sun>
Branch: map-position
Keep track of entities based on their map coordinates. Translate map coordinates into screen coordinates on render.
This should help with the collision issues so that movement is decoupled from the :player entity
- [ ] Add map-x and map-y to entities
- [ ] Add offset x and y to background layer
- [ ] On render apply offsets to the map and translate to screen changes
  - [ ] Tiles
  - [ ] Player
  - [ ] Monster

* TODO System for injecting adding/removing entities from the game state while game loop is running
* TODO Function to translate screen coords to map coords

* TODO Entity to Tile collision detection
- [ ] Boundary collisions (is a tile passable)
  - Check the players map position and find the nearest tile in the tile map
  - If the tile is passable then do nothing
  - If not then reset offset-x and offset-y to 0

* TODO Background rendering jumps using fixed timestep gameloop [/] <2014-04-05 Sat>
- Fix timestep loop causes rendering issues
  - When you put the render system in iter-systems the movement is correct
  - When it's not you get inconsistencies in the rendering where certain parts are moved in weird ways like the background or monster
because render gets called outside of the systems step loop
- Tiles are moving but the Monster is

** TODO Re-implement fixed timestep loop where render is outside of the timestep loop
Line 73 in engine.core

** TODO Add a new system for writing changes to screen coords after all systems complete
This way the render step is only for updating draw code and we don't have to be concerned with offsets
* TODO Multiple hit boxes per entity
- Entities should have body parts (multiple hit boxes)
- Body parts have a hitbox and are checked during collision detection
* TODO Test with simulation
Makes a series of state changes to the game and returns the end state once all steps are completed
Can be used for testing behavior visually and with real results
- [ ] Record game state
- [ ] Playback game state

* TODO Sprite animation rendering
- Fixed timestep animation?
  Each frame ticks the next frame in an animation
- Action list animation?
  This would allow the cancellation of an animation easily. Say a player is attacking and then get's hit halfway through the animation, could cancel the animation and start the hit animation
* TODO [#A] Sound system
System that reads an entities action list and global action list and plays the sound
* TODO Wrap pixi sprite calls into something more friendly
* TODO Make game-loop a function that takes in args for frame rate and main function to call
* TODO Draw ordering of entities to know which should be in front of what
* TODO When moving, keep the player in the center unless the border is < 1/2 the distance to the player then allow the player to move towards it
* TODO Action list
* TODO Inspect protocol
All game engine things must be inspectable, returning details about it's current state
* TODO Entity message passing
Pass a message from one entity to another and process the list of messages
Processing the list of messages can result in generating actions on the action list

* Profiling notes
- In the chrome js console profiler:
  - "self" is how much time was spent doing work directly in that function.
  - "total" is how much time was spent in that function, and in the functions it called.
** Profiling <2015-07-19 Sun>
- AI system profile
  - apply is 45% of the time spent
  - update-component-state-and-events 35%
    - Looks like emit events is the culprite with update-in happening many times
- Broad collision system
  - entities-with-multi-components 40% of time
  - mk-spatial-grid is 52% of time, looks like the group-by is inefficient
- Narrow collision system
  - Pretty small amount of time spent there
** Profiling <2015-07-25 Sat>
- narrow-collision detection takes 25%
  - check-collsions appears to be the culprit with 20% time spent there
- get-subscribed-events takes 22% of the overall profiled time
  - usage of mapcat appears to be the culprit with 20% time spent there
** Profiling <2015-08-01 Sat>
- Only looked at 2 systems movement and ai
- Major bottlenecks
  - apply (unoptimized by v8) in component-fn-body
  - emit-events reduce is spending lots of time and number of function calls will grow linearly with each entity added
  - get-events spends all it's time with get-in
* Live demo <2014-12-10 Wed>
Want to show how nice it is getting quick feedback loops and adding new features to the game
- Start a game from scratch and build it up
- Show how to inspect game state
- Show what it's like to work with
- Add a new system or feature
- Update an existing system on the fly
* Macros
** TODO defsystem
Takes a scene state and handler fn and returns a function
** TODO defgame
Takes a collection of scenes where the default scene is the first one
Implements a fixed time step game loop
Loads the stage (rendering engine)
What happens if there is more than one defgame?

** TODO defscene
A collection of systems and initial state for managing the systems. Returns an atom with a hashmap representing the scene state. Returns a hashmap of functions for managing the scene such as state resets
** TODO defentity does not work due to issues with eval from another ns
 - Metadata on def does not work in clojurescript
 - Eval inside a macro resolving a symbol from another ns does not work
 - Loading the caller's ns does not work https://github.com/teropa/hiccups/blob/master/src/clj/hiccups/runtime.clj
 - [ ] Bind to another ns in the macro http://stackoverflow.com/questions/7684656/clojure-eval-code-in-different-namespace

** TODO defaction
Creates a vector of actions used by an action list
** TODO deflevel
Defines a new level for the game
Takes a list of assets to load, which world map, game scripts to load etc

* DONE Version 0.1.0 [3/3]                                          :release:
CLOSED: [2015-01-18 Sun 20:55]
** DONE Core [2/2]
CLOSED: [2014-11-15 Sat 11:27]
- [X] Browser repl
- [X] Centralized logging
** DONE Scenes State Components Entities Systems [5/5]
CLOSED: [2014-11-22 Sat 11:35]
- [X] Scenes (collection of systems)
- [X] Systems (collection of component functions)
- [X] Entities (UIDs with collection of component IDs)
- [X] State (nested hashmap representing scene state)
- [X] Messaging (Event bus for sending and receiving messages between systems)
** DONE Systems/Components [8/8]
CLOSED: [2015-01-18 Sun 13:52]
- [X] Movement
- [X] Circle collision detection
- [X] Rendering
- [X] User input
- [X] Tile mapping
- [X] Debug layer (collision circles)
- [X] Replay game state (go back to old game state on the fly)
- [X] Animations (sprites)

* DONE Add diagonal movement
CLOSED: [2015-12-13 Sun 18:32]
* DONE Static lookups for component and system function calls
CLOSED: [2015-07-11 Sat 21:37]
- What if we just wrap all the higher order fns with defs?
- What if at the time of wiring we def everything or stick them the game state in a deftype?
  - engine.core/mk-game-state
  - Maybe ces/mk-component should def the functions then return the fully qualified names in the state hashmap
  - We already have a static number keys for the game state and should not allow anything else
    - scenes
    - game
    - systems
    - components
    - entities
- This didn't end up helping since I found that these issues only show up when dynamically loading things from the repl
* DONE Audio component <2015-05-24 Sun>
CLOSED: [2015-05-24 Sun 17:12]
* DONE Talk for LispNYC <2015-08-16 Sun>
CLOSED: [2015-09-25 Fri 10:28] DEADLINE: <2015-09-08 Tue>
- Topics
  - Profiling
  - Functional game engine design
  - Performance optimization of ClojureScript
  - Embedded repl as a game mechanic
* DONE Add static fn analysis and pseudo name optimization for min build <2015-08-01 Sat>
CLOSED: [2015-11-01 Sun 19:32]
- As per this blog post http://swannodette.github.io/2015/03/16/optimizing-clojurescript-function-invocation/ we can get better call site optimization
- Need extern file to work with advanced Google Closure optimization i.e https://github.com/cljsjs/packages/blob/master/d3/resources/cljsjs/d3/common/d3.ext.js
- Alternatively, refer to external libs by string name only
  (let [yay ((goog.object.get js/window "yayQuery"))]
    ((goog.object.get yay "sayHello") ((goog.object.get yay "getMessage"))))
- [ ] Extern file for pixijs
- [ ] Extern file for howlerjs
- [ ] Update project.clj under cljsbuild profile "min" build
  ;; Statically analyze function arrities
  :static true
  ;; Flatten namespace conventions into
  ;; names instead of nested objects
  :pseudo-names true
* DONE Spatial index for help reduce number of collision detections <2015-11-15 Sun>
CLOSED: [2015-11-15 Sun 22:12]
- Benchmarks http://0fps.net/2015/01/23/collision-detection-part-3-benchmarks/
- Good r-tree lib https://github.com/mourner/rbush
* DONE Remove circle radius from player and enemy entity constructor <2015-11-22 Sun>
CLOSED: [2015-11-27 Fri 15:16]
* DONE Optimize update-spatial-index <2015-11-15 Sun>
CLOSED: [2015-11-16 Mon 22:18]
- According to profiler it's really slow
- Seems like the root cause is get-multi-component-state function that only gets realized inside of update-spatial-index
* DONE Optimize collision detection as it seems to be the slowest system <2015-11-08 Sun>
CLOSED: [2015-11-15 Sun 22:11]
* DONE Optimize the ces framework
CLOSED: [2015-11-08 Sun 20:23]
- When you double the number of entities the framerate drops nearly in half
- AI system/component showcases this the best, removing it increases the framerate a ton
- How can we reduce the number of changes to the global state?
- Size of the state hashmap is not the problem
  Adding initial state of (reduce into {} (map hash-map (range 10000) (range 10000))) has no slow down even with 10000 additional keys
- Event messages the biggest issue?
  - Every time a system runs it can generate up to n number of state changes where n is the number of events emitted
  - Make the event queue a mutable object
    - Was super slow, see mutable-queue branch
  - Every time an event is emitted, mutate the queue instead of rewriting the state hashmap
  - Make the queue a hashmap instead of a hashmap and an array
    - Each message has it's own unique ID
    - To get all messages at a selector, iterate through all keys at that point
    - Only once per game loop will we need to return a new game state for the sake of events (when the queues are cleared)
  - Flatten the keys for events and
  - Batch all the events in one shot at the end of the system call\
* DONE Systems should only be running one component function instead of a collection <2015-08-02 Sun>
CLOSED: [2015-11-08 Sun 20:22]

* DONE Refactor events <2015-08-02 Sun>
CLOSED: [2015-08-16 Sun 18:23]
- Too slow
  Profiler shows bottleneck in emit-events and get-events
- Currently implemented as a nested hashmap of sequences of event hashmaps
- [X] Remove nesting?
  - Want a way to select what we need in one shot withouth walking a nested data structure
  - Should reduce time for getting events and emitting events if there is no nesting
  - Overload the names of the event to prevent nesting?
  - Do we need to give up hierarchical event subscriptions? Are they useful?
  - Removed nesting and that improves by a few frames
- [ ] Remove events in favor of directly querying component state
  - Would couple components implicitely
    - Is there a way to explicitely make the dependencies between entities and components states?
  - Instead of inbox, maybe replace with a read only queryable component state?
    - If you have direct access to objects then they can be mutated by something other than the component that owns the state
    - Components shouldn't have access to game meta state only component state

- [-] Reduce the usage of events
  - Movement/collision/animation is the challenging part to decouple
    :player1
    controllable -- moveable -- collision -- position -- animation

    :enemy1
    ai -- moveable -- collision -- position -- animation

  - [ ] Make a new component called position which is based on the movement and collision component states
    - [ ] Player1 movement component should query the input state and set the desired movement
    - [ ] Position component
    - [ ] For enemies, position component to set the offsets
    - [ ] Animateable queries position and action component state

  - [X] Use state machines instead of requiring a message to be present
    Example: Only send an event if something has changed instead of requiring a message every frame
    - [X] Update controllable/react-to-input to only emit an event if the state has changed
    - [X] Update moveable to only emit when movement has changed

* DONE Refactor component function args to all be a map instead of positional args <2015-08-16 Sun>
CLOSED: [2015-11-08 Sun 20:19]
- It would be hard to had additional functionality to component functions if we have to worry about breaking call signature changes
- [X] Change args to all component functions to be a single hashmap
- [ ] Rename :args-fn to something more appropriate
* DONE Fix V8 optimization bailout in ces/iter-entities <2015-07-26 Sun>
CLOSED: [2015-08-01 Sat 11:56]
- Error is "bad value context for arguments value"
- https://github.com/bevry/taskgroup/issues/12#issue-23512231
- https://code.google.com/p/v8/issues/detail?id=3037
- Fixed by making it a two arrity function
* DONE Clean up usage of apply in mk-component-fn <2015-07-25 Sat>
CLOSED: [2015-07-25 Sat 19:37]
* DONE mk-event should take a vector of selectors instead of varargs <2015-07-25 Sat>
CLOSED: [2015-07-25 Sat 19:37]
* DONE Benchmarks for the engine <2015-04-04 Sat>
CLOSED: [2015-04-04 Sat 13:29]
Use this to test any pervasive changes to the rest of the framework related to performance
- Use simple-benchmark which is built in which shows the running time for a function over n iterations
- [X] Calculate the number of frames per second the engine can do
- [X] Add best of calculation
- [X] Add basic stats
* DONE Remove use of filter to get a list of entities that have a component
CLOSED: [2015-04-04 Sat 14:41]
- Currently stored as :entitiy -> [:c1 :c2]
- Reverse it so that when an entity is created it is indexed to a direct lookup path i.e :component [:e1 :e2]
- Can use keys on :state -> :c1 to get all entities in one shot without a fitler then map
* DONE Update to latest pixijs <2015-05-03 Sun>
CLOSED: [2015-05-03 Sun 11:50]
- Update to v3
- Add as a submodule
* DONE Add stats.js to track frame rates
CLOSED: [2015-05-03 Sun 17:08]
https://github.com/mrdoob/stats.js
* DONE Eliminate unoptimized function calls in v8 due to needing dynamic lookup
CLOSED: [2015-07-11 Sat 21:38]
- Profiler says all the inner functions can not be optimized because the require a dynamic lookup and therefore can not be inlined by v8
- [X] Use macros to define a new function for each system/component instead of anonymous functions
- See branch defcomponent, didn't pan out as this isn't actually an issue on the first run
* DONE FIX debuggable collision circle overlay is not centered correctly
CLOSED: [2015-05-03 Sun 12:38]
* DONE Game loop helpers <2015-02-22 Sun>
CLOSED: [2015-03-07 Sat 21:22]
Make it easier to set up a game loop and constructing inital state
- [X] Game state helper
  Declare the function for a system, components and it will auto call mk-system/mk-component on them
- [X] Game loop helper
* DONE Update to latest version of austin and cljs <2015-02-21 Sat>
CLOSED: [2015-02-21 Sat 11:19]
- Austin 1.6 has issues so need to use version 1.7-SNAPSHOT or the repl doesn't work
- Had to update lein cljsbuild because it was to old to work with later cljs
- Now using the cljs required by core async latest
* DONE Add pixijs as a foreign dependency <2015-03-29 Sun>
CLOSED: [2015-11-08 Sun 20:23]
- https://github.com/clojure/clojurescript/wiki/Foreign-Dependencies
- No need to do this with externs
* DONE Live reloading during running game loop for any function change
CLOSED: [2015-11-27 Fri 15:17]
Looks like when the game loop is running the functions are immutable except in the case of multimethods so re evaluating a function does not guarantee that it will be used by the game engine.
- Update the lookups of system/component fns inside the game loop to lookup by reference rather than by value??
- This appears to work now <2015-11-27 Fri>
* DONE Benchmark for game engine performance <2015-03-07 Sat>
CLOSED: [2015-11-27 Fri 15:17]
- Use it to compare different implementations of the core game functions and optimize
- See chocolatier.engine.benchmarks for more
* DONE Use transients for local mutability <2015-02-01 Sun>
CLOSED: [2015-11-27 Fri 15:18]
- [X] Figure out where we can use transients instead of normal hashmap operations
  - Systems?
  - Components?
  - CES operations?
- [X] Change all systems to use transients
- [ ] Change collision detection to use transients of js arrays to do collision detection
  - No longer need to do this since implementing rbush for r-trees
- Doesn't seem to help that much, may revisit this <2015-11-27 Fri>
* DONE "Threads" using core.async to run systems async based on deps <2015-02-21 Sat>
CLOSED: [2015-02-22 Sun 15:50]
- Branch: async-systems
- Example:
  - Given dependency tree [[a b] [a c] [c d]]
  - Run in this order where a vector denotes async operation [a, [b c], d]
- Probably need to cache this when game loop is initialized and recalc anytime a new system is added/removed
- Turned out to be much slower due to overhead of core.async since these are all cpu bound tasks there is no benefit to async'ing them

* DONE Add direction to movement and animation so you remain in that direction when standing <2015-01-18 Sun>
CLOSED: [2015-01-25 Sun 12:36]
- [X] Add stand as an action if not walking to Controllable
- [X] FIX animation stack keeps growing
  Need to remove the last action if a new one comes in
* DONE Add attack animation <2015-01-25 Sun>
CLOSED: [2015-01-25 Sun 20:49]
* DONE Animation system <2015-01-17 Sat>
CLOSED: [2015-01-18 Sun 13:52]
- State machine for representing animations
- Hold on to the last state so that after an animation it goes back to what it was in
- State
  - Animation state key i.e. :walking :running
  - Frame number (for sprite sheet)
  - Dimensions of sprite sheet i.e width/height/frame-width/frame-height
- Abstraction for specifying an animation
- Key frame animation?
- Multi part sprites?
- [X] Renderable system should only call the stage render code
- [X] Move sprite updating based on movement to the animateable component
- [X] Can change to animateable system rather than renderable so all can share sprite stuff in one place. It only reacts to events so it's ok
  - Handles changes to sprites based on events including movement, animation, image swaps
- [X] Fix collision detection to use move component for position state or to get all info from the incoming event msg
- [X] Hold the hit zone info about an entity in the collidable component state
- [X] Position information should be held by the move component
* DONE Fix replay not working when pressing :B <2015-01-03 Sat>
CLOSED: [2015-01-03 Sat 17:41]
- Looks like new events evaluation causes replay to not work
- One of the systems is clearing out messages before it can make it to the replay system
- Systems were seqing over a hashmap which is not guaranteed to have order
* DONE Implement snapshots of game state and function to reload it <2014-12-07 Sun>
CLOSED: [2014-12-07 Sun 22:11]
- Take a copy of game state every n seconds and stick in vector
- Add an input control for a button to control stepping backward
- Thumbnail???? Would be super cool to render a mini image
* DONE Finish up selectors for events <2014-12-13 Sat>
CLOSED: [2014-12-13 Sat 21:11]
If there are keys instead of a seq then recursively concat all the messages down the tree
* DONE Update subscription calls to filter out messages properly using the passed in boolean function for determining if an even should go into an inbox
CLOSED: [2014-11-23 Sun 11:37]
* DONE Behavior component (for demo) <2014-11-22 Sat>
CLOSED: [2014-11-23 Sun 11:37]
- Implement an AI behavior for entities with the :ai component
- Chose to go towards the player on each turn

* DONE Collision detection takes too much cpu time <2014-11-22 Sat>
CLOSED: [2014-11-23 Sun 21:46]
Profiling shows 70% of all cpu time each trip through the game loop
- Alternatives
  - Perform the lookup in one shot for all entities
  - Sort by x, y, use x y to figure out which entities you should check against
  - Spatial grid, divide up all the entities into a 2D grid once per frame, only compare entities in the same frame
  - Cache the collision checks as you don't need to compare every entity in reverse A->B AND B->A
* DONE Add spatial grid system <2014-11-23 Sun>
CLOSED: [2014-11-23 Sun 21:46]

* DONE Fan out messages takes too much cpu time <2014-11-22 Sat>
CLOSED: [2014-11-28 Fri 19:32]
Profiling shows 20% of cpu time each trip through the game loop
- There was a message leak that was piling up in the queue
- Make event subscriptions opt in not opt out
- Subscribe to an event from someone to a specific ID
- Make broadcast subscriptions optional?
- Subscribe an entity to a specific event
  Subscribe a component?
  Subscribe an entity?
  What does the entity get in their inbox? All messages?
  When do you remove messages from inbox?
  Need better parsing of event messages
- Resulted in 2x framerate from 8-10 to 18-20

  Put the messages in a hashmap instead of a list
  {:events {:subscriptions {}
            :queue {:<event-id>
                     {:<source-id> [{:event-id :<event-id> :from :<from-entity> :msg <message>}]}}}}
  Subscribing to broadcast events is the concatenation of all values of keys nested in the event id
  A subscribed event is id -> from a specific entity

  Don't do a fan out as part of each system only check the events queue and make a lazy sequence that gets included as the inbox argument
  The event-system should clear out the event queue, handle new subscriptions/un-subscribes
* DONE Tiled tile map support <2014-12-07 Sun>
CLOSED: [2014-12-07 Sun 20:55]
Create a system for using tilemaps defined by Tiled
- [X] Load tile set image
- [X] Load json
- [X] Translate spec into tile set
  https://github.com/bjorn/tiled/wiki/TMX-Map-Format#tileset
  - imageheight, imagewidth, tileheight, tilewidth, tileproperties
  - The spec for the tiles is in data.layers[0].data and is a one dimensional array with numbers representing the tile to use
  - To get the x, y of the tile
    - number * tile width
    - by the width of the image divided by
- [ ] Update tile system to display it
  Needs to read the offsets of the tiles to shift the tileset image by x and y

* DONE Update documentation about event system <2015-01-03 Sat>
CLOSED: [2015-01-03 Sat 17:55]

* DONE Change game loop to wrap state in an atom so it can be inspected <2014-11-15 Sat>
CLOSED: [2014-11-15 Sat 17:34]
* DONE Fix controls does not register up and down <2014-11-16 Sun>
CLOSED: [2014-11-16 Sun 21:10]
* DONE Pixijs wrapper <2014-11-16 Sun>
CLOSED: [2014-11-16 Sun 17:14]
Hide all of the javascript interop to keep the api clean. Consider a polymorphic layer so that a different renderer can be swapped in.
* DONE [#A] Port existing components and systems to new CES refactor <2014-09-21 Sun> :core:
CLOSED: [2014-11-22 Sat 14:48]
- core
  - [X] game-loop
- systems
  - [X] render
  - [X] input
    Collects system input and stores it every loop
  - [X] user control
    Does something with the user input
  - [X] tiling
  - [X] movement
    Should handle reconciling user input to changes not sure how this is different than user control
    - It's different because without it you will not be able to check if you should make the next move resulting in a loop where you get stuck because you are always colliding
    - Can the entity make it's next move?
    - Should take a message from input about changes and move if there is not also a message for a collision
  - [X] collision detection
    Check against all entities to see if they are colliding
  - [X] debug layer (draw circles around entities)
    - Turn red when a message collision message is present in the inbox
    - Not sure how to do this without coupling renderable, collidable, and debuggable
    - Make the selector for entities check multiple component-ids to get entity ids
    - Make custom component state parsing function
  - [X] Repl changing of game state via state atom
* DONE [#A] Cross system/component communication [7/7] <2014-10-12 Sun> :core:
CLOSED: [2014-11-15 Sat 17:03]
Need a way to share information between systems and components
- [X] Component/Entity events mailbox
  - Each component should get access to it by default (can be nil)
  - Example (send-msg state :from-component-id :from-entity-id msg)
  - Messages are async, no response is given, all info must be in the message
- [X] Need a system to clear out messages
- [X] Fan out messages to all subscriber inboxes
- Read only component state if it is not yours
- [X] Default component functions should also take in an inbox as an argument by default
- [X] Provide a way of emitting event from any component by passing it in as an arg
  - Currently, the component function returns a hashmap which will be merged in to the game state
  - We also need to provide a way of conveying that an event(s) should be emitted
  - Component functions can output 1 or 2 items
    - If it's 1 item then it's the component state
    - If it's 2 items then it is component state and events
    - You can never just return events
- [X] Update game system fns now that component fns return updated game state rather than component state
  No longer need to use deep-merge which is recursive and costly. Instead use iter-fns on the collection of component fns in a system
- [X] Clear events inboxes after the system runs each component function
* DONE mk-component-fn should allow custom argument parsing function AND output wrapper <2014-10-12 Sun>
CLOSED: [2014-10-12 Sun 19:25]
- Currently, passing in a args-fn to mk-component-fn DOES NOT wrap the output of the function into a mergeable hashmap. The caller must handle it in the function. This is confusing since it is handled automatically if you don't pass in an args-fn.
- 9 times out of 10 you will want to automatically merge in component state
- This will get even harder to manage yourself if we have to handle merging of events
- Solution:
  - Allow optional argument parsing functions
    1. Calling the function with the desired arguments
    2. Wrapping the output of the function into something mergeable
* DONE [#A] Replace ces/deep-merge in systems with iter-fns since each component by default calls ces/update-component-state-and-events which returns an updated global state
CLOSED: [2014-11-16 Sun 17:24]
* DONE Make assertions in component functions to fail faster <2014-11-15 Sat>
CLOSED: [2014-11-15 Sat 13:13]
- [X] Throw an error if output is not a 2 item collection
- [X] Throw an error if component state or inbox or event-fn etc are nil

* DONE Change component state to not live in the component but under the :state key <2014-10-12 Sun>
CLOSED: [2014-10-12 Sun 17:20]
* DONE Validate component functions exist when called
CLOSED: [2014-10-04 Sat 22:46]
* DONE Validate system functions exist when called
CLOSED: [2014-10-04 Sat 22:46]
* DONE Scenes
CLOSED: [2014-09-21 Sun 16:23]
A list of systems and a encapsulated state that defines a different element of a game such as a menu or mini game
* DONE Polymorphic component functions
CLOSED: [2014-10-03 Fri 22:27]
- An entity should be able to implement it's own function to satisfy a component
- Multimethod with a default should work perfectly here
- Example
  Dispatch on the entity-id
  (defn default-update-sprite
    "Update the entities sprite"
    [component-state entity-id]
    (let [sprite (:sprite component-state)]
      ;; Mutate the x and y position
      (set! (.-position.x sprite) (:pos-x component-state))
      (set! (.-position.y sprite) (:pos-y component-state))
      component-state))

  (defmulti update-sprite
    (fn [component-state entity-id] entity-id)

  (defmethod update-sprite :default [component-state entity-id] default-update-sprite)
* DONE CES refactor to make it more functional <2014-07-06 Sun>
CLOSED: [2014-09-21 Sun 21:46]
- [X] Refactor to use a state hashmap which gets passed to all systems
- [X] Add tests for ces functions

* DONE Require state dependencies
CLOSED: [2014-10-04 Sat 19:18]
This is probably too restrictive. Instead allow an arguments function that parses state and is applied to the component function.
- Specify your state dependencies in your component function
- Call your component function with the state in the order specified
- Return value must be a vector of all state to be merged in
- Example:
  (defcomponent stuff [input stage me]
    (my-fn input stage me))
  Calls a fn to get deps out of state
  Takes the return result and makes it merg-able with global state
* DONE Bring back dynamic eval of the game loop since it is no longer an atom
CLOSED: [2014-10-04 Sat 00:39]
Need a way to re-eval systems/components/etc in a repl and have the changes go
defmulti seems to work for that
Components using defmulti work with reload
There was a bug that was causing the loop to exit early thus reload wasn't working
* DONE Systems should be by ID reference to a scene not a direct reference <2014-09-21 Sun>
CLOSED: [2014-09-21 Sun 17:21]
When running a scene it should lookup by keyword the reference to the system fn
* DONE defentity <2014-05-04 Sun>
CLOSED: [2014-05-04 Sun 12:51]
- Returns a defrecord with a hashmap of component Protocols and functions
- Reads :fields metadata of protocol and creates a list of all fields that will be the record's state
* DONE defcomponent <2014-05-04 Sun>
CLOSED: [2014-05-04 Sun 12:51]
- Creates a protocol
- Takes a name, state (hashmap of fields), and methods
- Returns a protocol with metadata about it's fields
* DONE Move all state to it's own ns
CLOSED: [2014-01-18 Sat 17:33] <2014-01-18 Sat>
* DONE Implement systems that are run on every step through the game loop <2014-01-18 Sat>
CLOSED: [2014-01-18 Sat 18:52]

* DONE FIX have to manually evaluate the systems.core/render/tick, input <2014-01-18 Sat>
CLOSED: [2014-01-19 Sun 16:36]
This was due to issues with the move of all state to engine.state ns and not recompiling the js. The smoking gun was that `game` was defined in engine.core not `s/game`
* DONE Basic keyboard WASD and directional arrow movement <2014-01-19 Sun>
CLOSED: [2014-01-19 Sun 17:31]
* DONE Implement fixed timestep gameploop <2014-01-20 Mon>
CLOSED: [2014-01-20 Mon 00:08]
http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
- time between game loop calls
* DONE Fix pausing game breaks the game loop <2014-01-20 Mon>
CLOSED: [2014-01-20 Mon 00:22]
- need to request the recur the loop
* DONE Make render perform the position changes <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 16:00]
to the sprite based on the current values of the record
* DONE Tiles
CLOSED: [2014-01-26 Sun 16:00]
* DONE Tile maps <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 21:41]
- [X] Change state to tile-map which is a hashmap with meta about the map and a list of Tile objects
* DONE Error thrown when resetting game
CLOSED: [2014-02-10 Mon 02:17]
Extra parenths in the callback would lead to a function call of the result of start-gamey
Uncaught TypeError: Object #<HTMLBodyElement> has no method 'call' VM491:2
(anonymous function) VM491:2
(anonymous function) VM487:10
cljs.core.Atom.cljs$core$IWatchable$_notify_watches$arity$3 core.cljs:7038
cljs.core._notify_watches core.cljs:340
cljs.core.reset_BANG_ core.cljs:7074
d core.cljs:7088
a core.cljs:7091
game_loop VM484:16
(anonymous function)
* DONE Batch translate by offset for a collection of tiles
CLOSED: [2014-02-10 Mon 02:02]
* DONE FIX dynamic loading of entities doesn't take effect <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 16:56]
Now that we perform state changes that produce a new record each transaction, changes to underlying protocols or records takes place immediately!
* DONE FIX multiple reset-games makes the input move double as fast each time until the canvas is removed <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 21:36]
Stop flag is not being caught in the game loop
Add a watcher and callback to reset the game
* DONE Move tiles based on the player's position <2014-02-07 Fri>
CLOSED: [2014-02-16 Sun 22:27]
- [X] Player needs to have a map position coordinate
- [X] Create a new component BackgroundLayer which is used by Tilemap to adjust it's tiles based on players position
- [X] UserInput should set the direction and the x y offset based on velocity
* DONE FIX Error thrown by the callback watcher on reset-game! <2014-01-26 Sun>
CLOSED: [2014-02-16 Sun 22:31]
* DONE FIX initial reset-game! does not work <2014-02-16 Sun>
CLOSED: [2014-03-02 Sun 15:07]
- systems is not loaded on engine.core load
  - This was due to compiled js being used instead
- the first time and requires calling start-game!
- there is a race condition where the renderer starts before the window has a width or height causing an error when pixijs renderer is called
- Need to load the asset for the tile background using an asset loader
  loader = new PIXI.AssetLoader(["resources/bg-far.png","resources/bg-mid.png"]);
  loader.onComplete = onAssetsLoaded
  loader.load();
  Then one can simply wrap the code into the onAssetsLoaded function
* DONE Move tiles into the game engine <2014-01-26 Sun>
CLOSED: [2014-03-02 Sun 15:19]
* DONE Each entity that is collidable needs to have a hit box radius
CLOSED: [2014-03-09 Sun 19:12]
* DONE Fix directory structure for cljs is not conventional <2014-03-14 Fri>
CLOSED: [2014-03-14 Fri 17:09]
Need a chocolatier dir

* DONE Debug layer needs to be moved to engine/state so that it can be coordinated during resets <2014-03-22 Sat>
CLOSED: [2014-03-22 Sat 20:01]
* DONE Add a watches namespace for tools to debug changes to state <2014-04-06 Sun>
CLOSED: [2014-04-06 Sun 14:27]
* DONE Collision detection for player causes the player to not be able to move (always colliding) <2014-03-14 Fri>
CLOSED: [2014-04-12 Sat 20:32]
- Prevent movement if the result of the move is a collision
- The player is able to move such that the circles are overlapping
  - Maybe the collision detection is wrong?
    - The formula seems to work
    chocolatier.engine.systems.collision> (collision? 352 220 20 322 186 30)
    true
    chocolatier.engine.systems.collision> (collision? 352 220 20 320 184 30)
    true
    chocolatier.engine.systems.collision> (collision? 352 220 20 317 181 30)
    false
  - Maybe the addition of the offset x/y is not being checked properly?
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 306 206 VM8682:9
    DEBUG: After offset 306 206 VM8682:9
    # THIS STARTS THE MOVE TOWARDS COLLISION
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    # THIS SHOULD HAVE RELEASED IT
    DEBUG: State changed :input-debug {:A "off"} VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    # Even after no offsets are being applied we still have a collision!
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206
  - Maybe the order of the systems is wrong?
    - Moved movement phase to right before the collision detection
    - Render phase now applies the offsets calculated and applies them to the sprite
  - !!! Player has an offset even though it's screen position will not change
    - Monster also has an offset based on the player's offset
    - [X] Use a global screen offset when user input comes in to control
    - [X] Other entities then use the screen offset for their own movement and screen position
    - Movement stop on collision works when both entities have collision detection on and the player is passed in to the collision check without any offsets
    - Tiling works correctly when offsetst are removed but the monster moves with the player equally
  - Debug log 1:
    DEBUG: State changed :input
        :W off -> on VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 328 -> 323
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 333 -> 328
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 338 -> 333
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
  - The input handler can be on constantly and the user input step takes the latest value of the atom during a run through the game loop
  - Player was able to perform an illegal move
    From
    (collision? 361 250 30 288 250 40)
    To
    (collision? 361 250 30 292 250 40)
    Even though they were colliding
- Player and monster are sharing the same offset-x and why which will negate each other during collision detection because the detector applies the offsets before checking. This makes it impossible to move away from a collision
- How movement works
  1. User input
  2. Player adds an offset based on user input
  3. Monster adds an offset based on the players offset
  4. Collision detection runs
  5. Offsets are removed if there is a collision
  6. Sprite positions updated based on applying offsets to screen position
- FIXED by removing offset of the player!

* DONE Entity to entity collision detection <2014-03-09 Sun>
CLOSED: [2014-04-12 Sat 20:38]
- [X] Collisions should be a core system run before movement
- [X] Entity collisions
  - Collision based on velocity and direction
  - Compare all entities to each other
- [X] Draw a circle for debugging in the render function
  chocolatier.engine.systems.debug

* DONE Change entities state to a hashmap instead of a vector <2014-04-06 Sun>
CLOSED: [2014-04-12 Sat 20:44]

* DONE Center hit zone to the middle of the player sprite <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:01]
* DONE Make entity height and width a value on Player and Monster <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:42]
- [X] Update entity-collision? fn to use that instead of getting a sprite attribute. This will make it easier to test just by using a hashmap instead of a hashmap with a sprite object
* DONE Collision detection is for too far away <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:46]
After adding height and width to entities, the collision is detected too early
Wrong value of radius being used in collision detection
