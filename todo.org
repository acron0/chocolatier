# Development Notes and TODO list
# Date stamps are when the task was started
# Closed stamps are when it was completed

#+TODO: TODO FIX | DONE WONT-DO

* FIX Text damage rendering to the top left corner sometimes
* FIX Sending out hit action event all enemy animations receive it?
- CHECK FIRST: pixi reuses textures or frames
- In animateable component:
  - It's getting stuck on :hit-up and won't revert back to :stand-down
    (when (= next-action :hit-up)
      (println "HIT UP" next-action current-animation-name))
  - Stack should have :stand-down in it, but only has :hit-up, this means that pushing the current action down the stack is not working
* DONE Submit talk for Clojure West <2016-01-27 Wed>
CLOSED: [2016-01-28 Thu 06:10]
** Bio:
DEADLINE: <2016-01-28 Thu 12:00>
Alex Kehayias is the CTO at Shareablee and works on biggish data problems to help brands and publishers win the social web. Clojure and Python are his weapons of choice by day and by night. He is an active musician, tech community organizer (ClojureNYC), and helps mentor people learning to code.
** Description:
Alex Kehayias shares the many joys and challenges of building a game engine in a functional style using Clojure and ClojureScript. Over the course of 2+ years, Alex has been actively writing (and rewriting) a functional game engine to find the ideal combination of a quick feedback loop, testing with data, and performance. Join in the sorrows and triumphs of bringing functional programming to web-based game development for fun and zero profit!
** Main Ideas:
1. Game loop as a reduce call
  Structuring the overall game loop as a reduction over a collection of functions into a data structure provides the benefits of functional purity, one way data flow, and easy testing.
2. Entity Component Systems are a perfect match for FP
  Breaking down games following an entity component system popularized by Scott Bilas and the Unity game engine brings the ability to describe complex behaviors with data instead of code which makes for faster iteration to help find the fun.
3. Functional programming comes at a cost
  Performance is always a concern in game programming and the additional usage of functional paradigms means additional overhead, but thankfully can be overcome thanks to the ClojureScript compiler and heavy reference of the core of Clojure.
** Past talks:
- Functional Game Engine Design @ LispNYC: https://vimeo.com/152433890
- Clojure Panel @ ClojureNYC: http://www.meetup.com/Clojure-NYC/events/224632241/
- Storm & Clojure: http://www.meetup.com/Clojure-NYC/events/219336391/
- And a few other workshops as part of the ClojureScript NYC meetup group
* TODO Update the sprite/text renderer component to cull if the entity is outside of the viewport
- Pixi doesn't cull sprites outside of the viewport according to http://www.html5gamedevs.com/topic/6691-how-does-pixi-deal-with-items-positioned-off-the-screen/
* TODO Add subscriptions to other entities' events
- Currently all subscriptions are only for the entity which means another entity can not subscribe to the same messages
- Would be useful to create say an entity with at text and move component that could follow around the player entity
- Per component override
* TODO Add assertions about the shape of the data in key areas of the framework
When dev-ing it's nice to not have to deal with nil errors i.e calling nil as a function, nil values, etc
- [ ] Systems can check that they are getting state that isn't empty
- [ ] Components can check that the component state matches expected
- [ ] Events can validate event messages
* TODO Add position offset to text component to better position text around an entity
* TODO Test coverage
- [ ] Core framework
- [ ] Components
- [ ] Systems
* TODO Store entity component labels in a set instead of a list/vector for faster comparisons
multi-component-entities has to put the collection of component ids for each entity into a set before calling subset? on it
* FIX Spear attack doesn't work unless pushing a direction key simultaneously
* TODO Use metadata to derive the boilerplate game state wiring
- Instead of manually specifying all of the attributes of a system/component/entity use meta data
- Example:
  - Component function has a component name of :foo:
    (defn cf {:component-name :foo} [] ...)
    (defn component-name [f] (:component-name (meta (var component-fn))))
    (component-name component-fn) => :foo
- You can include functions in metadata too so we could use that to introspect the component's name instead of hardcoding it, you would only need to require the component-fn which means the compiler will throw errors earlier
- Specify dependencies of components for the purpose of catching errors earlier such as depending on a component state that does not exist
- mk-component-fn can read the meta data and intelligently figure out what args to call the function with
  - Selected state ends up in the third argument to the component function (a hashmap)
  - This prevents having to write a function every time you want to read some other component-state, instead you could list it in the meta data
  - {:require-component-states [:moveable :collideable]}
  - {:subscriptions [:move :collision]}
  - Or with more sugar, a dsl for selecting state of the game/components etc
    {:require-state [[:game :stage] [:component :move] [:component :collision]]}
* TODO Add spinning to movement system
* TODO Batch all events at the system level? <2015-11-15 Sun>
- This resulted in really big gains when doing collision detection where each entity can create more than one event
- Batching events for the ai system brought much less improvement so there may be something inherent about the collision events that were more severe
- Would be nice to only deal with events at the component fn level
* TODO Optimize ev/get-subscribed-events <2015-11-15 Sun>
According to profiler it's really slow
* TODO Assets pipeline for asynchronously loading sounds/tiles/sprites/etc
- Provide a nice abstraction for declaring pipeline of functions for loading assets asynchronously so that it doesn't look like spaghetti
- Integrate that into the mk-game-state function to keep the whole thing declarative
* TODO Add example of audio to the demo
* TODO Gameloop macro to inline the entire program into one function block
- Read this somewhere that referencing a ton of functions all over the place is not good for performance or garbage collection
- Write a macro that explodes all code into one massive function
* FIX input->interaction is non-deterministic
The output of the interaction hashmap is non-deterministic
because it is iterating through a hashmap where ordering is not
guaranteed. Need to iterate through only the accepted keycodes and
check if the input-state shows the key is "on". That way order is
controlled by the caller
* TODO Moveable component-fn calls get-component-state twice for every entity
According to the compiler, the move component requires multiple get-component-state calls
* TODO Move rate should be calculated by Moveable and should have component state
- Controllable should give the intended action based on user input i.e. :walk/run/attack :left/right etc
- Another component should interpret that into a new screen position
- Moveable needs to know if there is a collision before moving and intended position
- Collideable needs to know the intended position of the character

* TODO Function that generates all the animation declarations in each direction
* TODO Key combinations from input
* TODO Add skip frames to animation declaration to control animation speed
* TODO Use transients for things that are going to be iterated over and only need a local mutable value.
Could work well for systems when iterating over them
* TODO Clean up tilemapping code
- [ ] Add tests
- [ ] Split up monster loops
* TODO Tiles that are non-traversable <2014-11-30 Sun>
Implement a tile map that checks for locations of entities that are collidable and sends an event if they are going to collide
- [ ] Create a spatial grid based on the map location (offset based on the view port of the screen)
- [ ] Put all tile collidable entities into their coordinates
- [ ] Iterate over all occupied tiles
- [ ] If they will be on a non-traversable tile, emit a tile collision event

* TODO Optimizations <2014-11-29 Sat>
- Systems iterate over all entities that have the component and then each component function
- Try to batch all the changes to the game-state in one shot
- Try using the reducers library for zero allocation collection operations
- Update component state and emit events takes up a significant amount of time
  number of hashmap ops = number of systems * number of entities with component * number of functions * number of events
- Lots of analysis on clojurescript performance http://wagjo.github.io/benchmark-cljs/
- [-] Use custom types using (.-a my-map) instead of keywords should be 3x faster <2014-11-30 Sun>
  - What about a macro that replaces get-in, assoc-in, update-in?
    Would need to always use our version of it which is dumb
  - Implement protocols for the custom type so that all the clojure map functions work with it
  - Underlying data structure will be a js array
  - [ ] Remove usage of assoc-in
    ./chocolatier/engine/ces.cljs:29:  (assoc-in state [:scenes uid] system-ids))
    ./chocolatier/engine/ces.cljs:68:  (assoc-in state [:entities uid] component-ids))
    ./chocolatier/engine/ces.cljs:86:  (assoc-in state [:state component-id entity-id] val))
    ./chocolatier/engine/ces.cljs:173:    (assoc-in state [:components uid] {:fns wrapped-fns})))
    ./chocolatier/engine/ces.cljs:211:    (assoc-in state [:systems uid] system-fn)))
    ./chocolatier/engine/systems/collision.cljs:101:      (assoc-in state [:state :spatial-grid] grid))))
    ./chocolatier/engine/systems/events.cljs:71:  (assoc-in state [:state :events :queue] {}))
    ./chocolatier/engine/systems/events.cljs:76:  (assoc-in state [:state :events] {:queue {} :subscriptions {}}))
    ./chocolatier/engine/systems/input.cljs:48:  (assoc-in state [:game :input] @KEYBOARD-INPUT))
    ./chocolatier/engine/systems/tiles.cljs:42:    (assoc-in state [:state :tiles]
    ./chocolatier/engine/systems/tiles.cljs:53:    (assoc-in state [:state :tiles] tiles)))
    ./chocolatier/entities/enemy.cljs:28:        (assoc-in [:state :renderable uid] init-render-state)
    ./chocolatier/entities/player.cljs:27:          (assoc-in [:state :renderable uid] init-render-state)
  - [ ] Remove usage of get-in
    ./chocolatier/engine/ces.cljs:81:  (or (get-in state [:state component-id entity-id]) {}))
    ./chocolatier/engine/systems/events.cljs:36:  (let [subscriptions (get-in state [:state :events :subscriptions entity-id])
    ./chocolatier/engine/systems/events.cljs:37:        events (get-in state [:state :events :queue])]
    ./chocolatier/engine/systems/events.cljs:38:    (mapcat #(get-in events (if (seqable? %) % [%])) subscriptions)))
  - [ ] Remove usage of update-in
    ./chocolatier/engine/systems/events.cljs:31:  (update-in state [:state :events :subscriptions entity-id] conj selectors))
    ./chocolatier/engine/systems/events.cljs:61:    (update-in state (concat [:state :events :queue] selectors) conj event)))
  - This did not end up working because of the semantics of property access ".-" makes it impossible to construct at compile time without evaling symbols which means they can not be dynamically evalualted by putting thename of the key in a var for instance.
- [ ] Batch game state changes
  - After every system take all of the changes from component entities and events and make the update in one shot
  - Uses many assoc-in
  - Should components operate on all entities at the same time? That would allow a single assoc-in to the game state from the accumulated component state that could be reduced in

* TODO Use a context buffer instead of writing all to one canvas
- This should speed up the rendering of lots of sprites
- Example code
        function onLoad() {
            // init stats
            var stats = new Stats();
            stats.getDomElement().style.position = 'absolute';
            stats.getDomElement().style.left = '0px';
            stats.getDomElement().style.top = '0px';
            document.body.appendChild( stats.getDomElement() );
            setInterval( function () { stats.update(); }, 1000 / 60 );

            // cache dom elements
            canvas = document.getElementById('my_canvas');
            context = canvas.getContext('2d');
            width = canvas.width;
            height = canvas.height;
            shipImage = document.getElementById('ship');

            // create canvas buffer
            canvasBuffer = document.createElement('canvas');
            contextBuffer = canvasBuffer.getContext('2d');
            canvasBuffer.width = 100;
            canvasBuffer.height = 100;
            contextBuffer.translate(50, 50); // so we can rotate about the center point

            // create lookup table for trig functions
            angleIncrement = Math.PI / 12;
            lookupTable = [];
            for (var i = 0; i < 5000; i++) {
                lookupTable[i] = {
                    x: Math.cos(i) * width - 150,
                    y: Math.sin(i) * height - 150
                };
            }

            // kick off the loop
            window.setInterval(update, 16);
        }

        // this is called using a 16 ms interval
        function update() {

            // draw transformed ship image to a canvas buffer
            contextBuffer.clearRect(0, 0, 100, 100);
            contextBuffer.rotate(angleIncrement);
            contextBuffer.drawImage(shipImage, 0, 0, 50, 50);

            // draw 5,000 ships
            for (var i = 0; i < 5000; i++) {
                var lookup = lookupTable[i];
                context.drawImage(canvasBuffer, lookup.x, lookup.y);
            }
        }
* TODO Use AABBTree (Axis aligned Bounding Box Tree) for collision detection
* TODO Make the input system emit an event
Currently it updates it's component state but that's it. SHould send an event to avoid other components querying it directly

* TODO Change mk-component to also handle subscribing to events
* TODO Change mk-system to also register it with a scene id
* TODO Query-like functionality for state                              :core:
Send a query with what you want and a filter function
Returns a sequence
* TODO Reset the game height on screen resize                          :core:
* TODO Protection against overflowing messages
  Throw an error if two many messages are generated. This will prevent avalanches and fail faster so it is easier to diagnose problems.
  - [ ] Limit on number of messages in an inbox
  - [ ] Limit on number of messages in the event queue

* TODO Change 'state' to 'game' everywhere it is passed in as an argument
game -> :state is where the state lives, everything else is game related such as systems, components, platform, etc
* TODO Tests [2/3] <2014-10-04 Sat>
- [X] CES internals
- [ ] Input system/components
- [X] Event system

* TODO Re-implement fixed timestep loop
http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
* TODO During movement change the players map position <2014-03-23 Sun>
Branch: map-position
Keep track of entities based on their map coordinates. Translate map coordinates into screen coordinates on render.
This should help with the collision issues so that movement is decoupled from the :player entity
- [ ] Add map-x and map-y to entities
- [ ] Add offset x and y to background layer
- [ ] On render apply offsets to the map and translate to screen changes
  - [ ] Tiles
  - [ ] Player
  - [ ] Monster

* TODO Function to translate screen coords to map coords

* TODO Entity to Tile collision detection
- [ ] Boundary collisions (is a tile passable)
  - Check the players map position and find the nearest tile in the tile map
  - If the tile is passable then do nothing
  - If not then reset offset-x and offset-y to 0

* TODO Multiple hit boxes per entity
- Entities should have body parts (multiple hit boxes)
- Body parts have a hitbox and are checked during collision detection
* TODO Test with simulation
Makes a series of state changes to the game and returns the end state once all steps are completed
Can be used for testing behavior visually and with real results
- [ ] Record game state
- [ ] Playback game state

* TODO Sprite animation rendering
- Fixed timestep animation?
  Each frame ticks the next frame in an animation
- Action list animation?
  This would allow the cancellation of an animation easily. Say a player is attacking and then get's hit halfway through the animation, could cancel the animation and start the hit animation
* TODO [#A] Sound system
System that reads an entities action list and global action list and plays the sound
* TODO Make game-loop a function that takes in args for frame rate and main function to call
* TODO Draw ordering of entities to know which should be in front of what
* TODO When moving, keep the player in the center unless the border is < 1/2 the distance to the player then allow the player to move towards it
* TODO Inspect protocol
All game engine things must be inspectable, returning details about it's current state
