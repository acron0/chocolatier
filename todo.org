# Development Notes and TODO list
# Date stamps are when the task was started
# Closed stamps are when it was completed

#+TODO: TODO FIX | DONE WONT-DO

* TODO Initial release
- [ ] Move out anything that is not a core system or component into examples
- [ ] Provide tutorial example with graphics (devcards)
- [ ] Component state validation?
  Not sure if this should be the responsibility of the game engine or not sinc ethere are many ways to handle validation and assertions
- [X] Inspector integration?
  This can be a library, but could be useful for beginners
- [ ] Lein template
  Everything needed with a basic setup of a game
- [ ] Better example game
  - [ ] Nicer tile map
  - [ ] Nicer sprites
  - [ ] Obligatory Flappy Bird?
* DONE Add type hints before if statements to avoid extra checking
CLOSED: [2016-03-03 Thu 21:41]
(if ^boolean (pred v) ...)
* TODO Refactor system functions
- [X] Systems should provide the lens for component functions instead of wrapping all the component functions
- [X] Update all the component state in one shot instead of updating the state for each entity->component
  - Assumes there can be no inter system component state access or message passing
- [X] Figure out how to handle events
  Accumulate it using a transient and then emit it later
- [X] Update mk-system with less boilerplate for creating a system and an accompanying component
  - Component's are ALWAYS part of a system, a system does not always work on a component
  - Avoid errors like not having a component function that is called by a system function
  - Could present opportunities for optimization if we can guarantee the component fn is there
  - API
    - Custom system [:system :s1 my-system-fn]
    - System with component [:system :s2 :c1 my-component-fn]
- [X] Update benchmarks
- [X] Remove mk-component-fn if it's no longer used
- [ ] Update tests
  - [ ] mk-system-fn
    - [ ] Test events get emitted
    - [ ] Test component state gets updated
  - [ ] get-component-context
- [X] Systems should still declare what components they work on so it's not hardcoded into the implementation
  - What about multiple components?
    - Example: Collision detection works on entities that have movement and collision
  - If they don't work on a component then idiomatically use "global"
- [X] Replace all args-fn with select-components
  - What about when you need some global state like input?
  - What if you need component state for a different entity?
- [X] Replace format-fn used by the ai system
  - Probably want a custom system instead
  - TODO need to remove the hardcoding of the component name
- [ ] Update action rpg example
  - [ ] Update any systems that do anything special to implement their own system fn
  - [ ] Delete any systems that are generic
* TODO Refactor the ai system to something more sane
* TODO Refactor the keyboard input system to emit events on change
* TODO Make utils.counters 1 element js arrays for better performance
* TODO Change any use of = or not= to identical?
* TODO Replace usage of map/filter/for with eager implementations
* TODO Cache dynamic lookups in the game loop
- There are many places that use dynamic lookups to get things like the list of entities, components, etc that could be cached
- If you cache, need a way to invalidate the cache
- Shouldn't v8 be doing this already?
* TODO Remove anonymous functions
- [ ] Game loop creates a new anonymous function every time the game loop recurs
- [ ] Component functions are anonymous functions
  - Also loose ability to have the repl rebind it dynamically once it's in the game loop
- [ ] System functions are anonymous
* DONE Create a reverse lookup for checking entities given a component label
CLOSED: [2016-02-27 Sat 15:48]
- Currently, to get entities that have a component you would need to get all keys in that component's state which is not very intuitive
- There should be a way of looking up all the components an entity has
- There should be a way of looking up all entities for a given component
- The index should be a set to guarantee uniqueness
* FIX Fix all keys being captures by input system and it should only be in a certain scope
* DONE Explore the use the entity ID to handle polymorphism?
CLOSED: [2016-03-03 Thu 12:00]
- Instead of entity IDs being labels they can be types
- If they are known types then we can make component fns which are protocol methods
- This would allow you to create per entity ID polymorphism, i.e player1, some boss, have different movement rules?
- Would need a macro that copies all the functionality of the Keyword class so it can still be used for looking up things in the game state
- Issues:
  - Dispatch of implementation would be per entity so if we want all enemies to share the same implementation would need a lot of copying
- Example:
  #+begin_src clojure
  (defprotocol Moveable
    (move [this component-state context]
      "Handle whether or not the entity should move"))

  (extend-type Player1
    Moveable
    (move [this component-state {:keys [inbox]}]
      (let [{:keys [pos-x pos-y move-rate direction]} component-state
            {new-direction :direction} (:msg (get-move-change-event inbox))
            collision? (collision-event? inbox)]
        (let [next-direction (or new-direction direction)
              [offset-x offset-y] (if collision?
                                    [0 0]
                                    (mapv #(* move-rate %)
                                          (direction->offset next-direction)))]
          (assoc component-state
                 :pos-x (- pos-x offset-x)
                 :pos-y (- pos-y offset-y)
                 :offset-x offset-x
                 :offset-y offset-y
                 :move-rate move-rate
                 :direction next-direction)))))
  #+end_src

* DONE Component state as defrecords perf improvement?
CLOSED: [2016-02-24 Wed 13:53]
- Could also solve the validation problem so all keys are known up front
- In the benchmarks it didn't make a difference
* DONE Make component state mutable
CLOSED: [2016-02-24 Wed 16:48]
- Same benefit if you use transient or a js-obj
- Tested in benchmarks js objects and transient hashmaps performed 40% better that persistent maps
- In the running game engine though there was not much of a difference in the overall frame rate
  See the flatten-state branch for more
- [ ] Don't return a new object, return the same one so we are not creating new data structures every time
* TODO Test runner for js tests via PhantomJS
https://github.com/emezeske/lein-cljsbuild/blob/1.1.2/doc/TESTING.md
* DONE Use reducer for events/get-subscribed-events
CLOSED: [2016-02-23 Tue 04:19]
Doesn't make any noticeable difference
* DONE Move event functions out of chocolatier.systems.events and into chocolatier.events
CLOSED: [2016-02-23 Tue 04:51]
* DONE Rename ces namespace to ecs
CLOSED: [2016-02-23 Tue 05:31]
* TODO Self hosted cljs integration
Can we get the whole library and examples bootstrapped using self compiled cljs?
- Replumb is a library for creating your own
- Here's a nice implementation of a repl https://github.com/jaredly/reepl
* TODO Remove mk- prefix from functions as per convention
* TODO Refactor attacking
- [ ] Delete hitpoints namespace as it is not being used
- [ ] Don't overload collision events with data about damage
- [ ] Query the damage amount from the component state of the entity that is being collided with
* TODO FX system
- Global effects such as grayscale, waves, pixelate, color tint
- Entity effects limited in scope to the entity
* TODO Add meta tags to component data for inspector to provide help text for fields
- Example: (meta ^{:doc "yo"} {:a 1})
- This doesn't work with the evaluation model of praline because the parent would hold the information and need to pass it to the child
* DONE Text damage rendering to the top left corner
CLOSED: [2016-02-14 Sun 11:03]
- :cleanup-fn is not being called when an entity is being removed from the scene
- Can we make that automatically declared by the component instead of in the wiring up?
* FIX Sending out hit action event all enemy animations receive it?
- CHECK FIRST: pixi reuses textures or frames
- In animateable component:
  - It's getting stuck on :hit-up and won't revert back to :stand-down
    (when (= next-action :hit-up)
      (println "HIT UP" next-action current-animation-name))
  - Stack should have :stand-down in it, but only has :hit-up, this means that pushing the current action down the stack is not working
* DONE Inspector
CLOSED: [2016-02-23 Tue 19:46]
- Show the component states of an entity and be able to adjust it
- Implement as dom elements
- [X] Make game-loop take a state atom to copy state into every trip through the game loop
- [X] Auto generate form of component state selected
- [X] If something is changed, write the change into the game state
  - This should happen in real time
  - Maybe specify if you want to override the current component state with what's in the inspector ignoring game loop?
- [X] Abstraction for adding functionality at the game loop level?
  - This could be useful for tooling
  - Logging
  - Created middleware to address this
- [X] Remove the checkouts directory when done integrating
* DONE Remove text and styles from mk-text-sprite-state
CLOSED: [2016-02-22 Mon 09:52]
It should be only needed for the text component so there is separation from state and rendering
* DONE Submit talk for Clojure West <2016-01-27 Wed>
CLOSED: [2016-01-28 Thu 06:10]
DEADLINE: <2016-01-28 Thu 12:00>
** Bio:
Alex Kehayias is the CTO at Shareablee and works on biggish data problems to help brands and publishers win the social web. Clojure and Python are his weapons of choice by day and by night. He is an active musician, tech community organizer (ClojureNYC), and helps mentor people learning to code.
** Description:
Alex Kehayias shares the many joys and challenges of building a game engine in a functional style using Clojure and ClojureScript. Over the course of 2+ years, Alex has been actively writing (and rewriting) a functional game engine to find the ideal combination of a quick feedback loop, testing with data, and performance. Join in the sorrows and triumphs of bringing functional programming to web-based game development for fun and zero profit!
** Main Ideas:
1. Game loop as a reduce call
  Structuring the overall game loop as a reduction over a collection of functions into a data structure provides the benefits of functional purity, one way data flow, and easy testing.
2. Entity Component Systems are a perfect match for FP
  Breaking down games following an entity component system popularized by Scott Bilas and the Unity game engine brings the ability to describe complex behaviors with data instead of code which makes for faster iteration to help find the fun.
3. Functional programming comes at a cost
  Performance is always a concern in game programming and the additional usage of functional paradigms means additional overhead, but thankfully can be overcome thanks to the ClojureScript compiler and heavy reference of the core of Clojure.
** Past talks:
- Functional Game Engine Design @ LispNYC: https://vimeo.com/152433890
- Clojure Panel @ ClojureNYC: http://www.meetup.com/Clojure-NYC/events/224632241/
- Storm & Clojure: http://www.meetup.com/Clojure-NYC/events/219336391/
- And a few other workshops as part of the ClojureScript NYC meetup group
* TODO Rename components with -able                                 :cleanup:
i.e animateable -> animation
* TODO Update the sprite/text renderer component to cull if the entity is outside of the viewport
- Pixi doesn't cull sprites outside of the viewport according to http://www.html5gamedevs.com/topic/6691-how-does-pixi-deal-with-items-positioned-off-the-screen/
* TODO Get rid of the event bus in favor of reading component state directly :idea:
- Similar to React, instead of events to pass data, directly subscribe to other components
- Can infer which components are coupled similar to how reagent does it
- Can make component subscriptions explicit in the game wiring
  Instead of subscriptions, provide collection of component labels
- Currently all subscriptions are of components for the same entity, but in theory it doesn't have to be i.e global events
- Having an event bus means component state can change, but downstream component state does not
- Down stream would have to have logic for interpreting the state of the upstream component and they would thus be strongly coupled
* TODO Add subscriptions to other entities' events
- Currently all subscriptions are only for the entity which means another entity can not subscribe to the same messages
- Would be useful to create say an entity with at text and move component that could follow around the player entity
- Per component override
* TODO Auto generate a schema for component state
- Derive the component-state schema
- Explicitely or implicitely?
  Implicitely could use records and mk-state functions would have to return a record
- When fields are updated in dev, perform a schema assertion (maybe using prismatic schema?)
* TODO Add assertions about the shape of the data in key areas of the framework
When dev-ing it's nice to not have to deal with nil errors i.e calling nil as a function, nil values, etc
- [ ] Systems can check that they are getting state that isn't empty
- [ ] Components can check that the component state matches expected
- [ ] Events can validate event messages
* TODO Add position offset to text component to better position text around an entity
* TODO Test coverage
- [ ] Core framework
- [ ] Components
- [ ] Systems
* TODO Store entity component labels in a set instead of a list/vector for faster comparisons
multi-component-entities has to put the collection of component ids for each entity into a set before calling subset? on it
* FIX Spear attack doesn't work unless pushing a direction key simultaneously
* TODO Use metadata to derive the boilerplate game state wiring
- Instead of manually specifying all of the attributes of a system/component/entity use meta data
- Example:
  - Component function has a component name of :foo:
    (defn cf {:component-name :foo} [] ...)
    (defn component-name [f] (:component-name (meta (var component-fn))))
    (component-name component-fn) => :foo
- You can include functions in metadata too so we could use that to introspect the component's name instead of hardcoding it, you would only need to require the component-fn which means the compiler will throw errors earlier
- Specify dependencies of components for the purpose of catching errors earlier such as depending on a component state that does not exist
- mk-component-fn can read the meta data and intelligently figure out what args to call the function with
  - Selected state ends up in the third argument to the component function (a hashmap)
  - This prevents having to write a function every time you want to read some other component-state, instead you could list it in the meta data
  - {:require-component-states [:moveable :collideable]}
  - {:subscriptions [:move :collision]}
  - Or with more sugar, a dsl for selecting state of the game/components etc
    {:require-state [[:game :stage] [:component :move] [:component :collision]]}
* TODO Add spinning to movement system
* TODO Batch all events at the system level? <2015-11-15 Sun>
- This resulted in really big gains when doing collision detection where each entity can create more than one event
- Batching events for the ai system brought much less improvement so there may be something inherent about the collision events that were more severe
- Would be nice to only deal with events at the component fn level
* TODO Optimize ev/get-subscribed-events <2015-11-15 Sun>
According to profiler it's really slow
* TODO Assets pipeline for asynchronously loading sounds/tiles/sprites/etc
- Provide a nice abstraction for declaring pipeline of functions for loading assets asynchronously so that it doesn't look like spaghetti
- Integrate that into the mk-game-state function to keep the whole thing declarative
* TODO Add example of audio to the demo
* TODO Gameloop macro to inline the entire program into one function block
- Read this somewhere that referencing a ton of functions all over the place is not good for performance or garbage collection
- Write a macro that explodes all code into one massive function
* FIX input->interaction is non-deterministic
The output of the interaction hashmap is non-deterministic
because it is iterating through a hashmap where ordering is not
guaranteed. Need to iterate through only the accepted keycodes and
check if the input-state shows the key is "on". That way order is
controlled by the caller
* TODO Moveable component-fn calls get-component-state twice for every entity
According to the compiler, the move component requires multiple get-component-state calls
* TODO Move rate should be calculated by Moveable and should have component state
- Controllable should give the intended action based on user input i.e. :walk/run/attack :left/right etc
- Another component should interpret that into a new screen position
- Moveable needs to know if there is a collision before moving and intended position
- Collideable needs to know the intended position of the character

* TODO Function that generates all the animation declarations in each direction
* TODO Key combinations from input
* TODO Add skip frames to animation declaration to control animation speed
* TODO Use transients for things that are going to be iterated over and only need a local mutable value.
Could work well for systems when iterating over them
* TODO Clean up tilemapping code
- [ ] Add tests
- [ ] Split up monster loops
* TODO Tiles that are non-traversable <2014-11-30 Sun>
Implement a tile map that checks for locations of entities that are collidable and sends an event if they are going to collide
- [ ] Create a spatial grid based on the map location (offset based on the view port of the screen)
- [ ] Put all tile collidable entities into their coordinates
- [ ] Iterate over all occupied tiles
- [ ] If they will be on a non-traversable tile, emit a tile collision event

* TODO Optimizations <2014-11-29 Sat>
- Systems iterate over all entities that have the component and then each component function
- Try to batch all the changes to the game-state in one shot
- Try using the reducers library for zero allocation collection operations
- Update component state and emit events takes up a significant amount of time
  number of hashmap ops = number of systems * number of entities with component * number of functions * number of events
- Lots of analysis on clojurescript performance http://wagjo.github.io/benchmark-cljs/
- [-] Use custom types using (.-a my-map) instead of keywords should be 3x faster <2014-11-30 Sun>
  - What about a macro that replaces get-in, assoc-in, update-in?
    Would need to always use our version of it which is dumb
  - Implement protocols for the custom type so that all the clojure map functions work with it
  - Underlying data structure will be a js array
  - [ ] Remove usage of assoc-in
    ./chocolatier/engine/ces.cljs:29:  (assoc-in state [:scenes uid] system-ids))
    ./chocolatier/engine/ces.cljs:68:  (assoc-in state [:entities uid] component-ids))
    ./chocolatier/engine/ces.cljs:86:  (assoc-in state [:state component-id entity-id] val))
    ./chocolatier/engine/ces.cljs:173:    (assoc-in state [:components uid] {:fns wrapped-fns})))
    ./chocolatier/engine/ces.cljs:211:    (assoc-in state [:systems uid] system-fn)))
    ./chocolatier/engine/systems/collision.cljs:101:      (assoc-in state [:state :spatial-grid] grid))))
    ./chocolatier/engine/systems/events.cljs:71:  (assoc-in state [:state :events :queue] {}))
    ./chocolatier/engine/systems/events.cljs:76:  (assoc-in state [:state :events] {:queue {} :subscriptions {}}))
    ./chocolatier/engine/systems/input.cljs:48:  (assoc-in state [:game :input] @KEYBOARD-INPUT))
    ./chocolatier/engine/systems/tiles.cljs:42:    (assoc-in state [:state :tiles]
    ./chocolatier/engine/systems/tiles.cljs:53:    (assoc-in state [:state :tiles] tiles)))
    ./chocolatier/entities/enemy.cljs:28:        (assoc-in [:state :renderable uid] init-render-state)
    ./chocolatier/entities/player.cljs:27:          (assoc-in [:state :renderable uid] init-render-state)
  - [ ] Remove usage of get-in
    ./chocolatier/engine/ces.cljs:81:  (or (get-in state [:state component-id entity-id]) {}))
    ./chocolatier/engine/systems/events.cljs:36:  (let [subscriptions (get-in state [:state :events :subscriptions entity-id])
    ./chocolatier/engine/systems/events.cljs:37:        events (get-in state [:state :events :queue])]
    ./chocolatier/engine/systems/events.cljs:38:    (mapcat #(get-in events (if (seqable? %) % [%])) subscriptions)))
  - [ ] Remove usage of update-in
    ./chocolatier/engine/systems/events.cljs:31:  (update-in state [:state :events :subscriptions entity-id] conj selectors))
    ./chocolatier/engine/systems/events.cljs:61:    (update-in state (concat [:state :events :queue] selectors) conj event)))
  - This did not end up working because of the semantics of property access ".-" makes it impossible to construct at compile time without evaling symbols which means they can not be dynamically evalualted by putting thename of the key in a var for instance.
- [ ] Batch game state changes
  - After every system take all of the changes from component entities and events and make the update in one shot
  - Uses many assoc-in
  - Should components operate on all entities at the same time? That would allow a single assoc-in to the game state from the accumulated component state that could be reduced in

* TODO Use a context buffer instead of writing all to one canvas
- This should speed up the rendering of lots of sprites
- Example code
        function onLoad() {
            // init stats
            var stats = new Stats();
            stats.getDomElement().style.position = 'absolute';
            stats.getDomElement().style.left = '0px';
            stats.getDomElement().style.top = '0px';
            document.body.appendChild( stats.getDomElement() );
            setInterval( function () { stats.update(); }, 1000 / 60 );

            // cache dom elements
            canvas = document.getElementById('my_canvas');
            context = canvas.getContext('2d');
            width = canvas.width;
            height = canvas.height;
            shipImage = document.getElementById('ship');

            // create canvas buffer
            canvasBuffer = document.createElement('canvas');
            contextBuffer = canvasBuffer.getContext('2d');
            canvasBuffer.width = 100;
            canvasBuffer.height = 100;
            contextBuffer.translate(50, 50); // so we can rotate about the center point

            // create lookup table for trig functions
            angleIncrement = Math.PI / 12;
            lookupTable = [];
            for (var i = 0; i < 5000; i++) {
                lookupTable[i] = {
                    x: Math.cos(i) * width - 150,
                    y: Math.sin(i) * height - 150
                };
            }

            // kick off the loop
            window.setInterval(update, 16);
        }

        // this is called using a 16 ms interval
        function update() {

            // draw transformed ship image to a canvas buffer
            contextBuffer.clearRect(0, 0, 100, 100);
            contextBuffer.rotate(angleIncrement);
            contextBuffer.drawImage(shipImage, 0, 0, 50, 50);

            // draw 5,000 ships
            for (var i = 0; i < 5000; i++) {
                var lookup = lookupTable[i];
                context.drawImage(canvasBuffer, lookup.x, lookup.y);
            }
        }
* TODO Use AABBTree (Axis aligned Bounding Box Tree) for collision detection
* TODO Make the input system emit an event
Currently it updates it's component state but that's it. SHould send an event to avoid other components querying it directly

* TODO Change mk-component to also handle subscribing to events
* TODO Change mk-system to also register it with a scene id
* TODO Query-like functionality for state                              :core:
Send a query with what you want and a filter function
Returns a sequence
* TODO Reset the game height on screen resize                          :core:
* TODO Protection against overflowing messages
  Throw an error if two many messages are generated. This will prevent avalanches and fail faster so it is easier to diagnose problems.
  - [ ] Limit on number of messages in an inbox
  - [ ] Limit on number of messages in the event queue

* TODO Change 'state' to 'game' everywhere it is passed in as an argument
game -> :state is where the state lives, everything else is game related such as systems, components, platform, etc
* TODO Tests [2/3] <2014-10-04 Sat>
- [X] CES internals
- [ ] Input system/components
- [X] Event system

* TODO Re-implement fixed timestep loop
http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
* TODO During movement change the players map position <2014-03-23 Sun>
Branch: map-position
Keep track of entities based on their map coordinates. Translate map coordinates into screen coordinates on render.
This should help with the collision issues so that movement is decoupled from the :player entity
- [ ] Add map-x and map-y to entities
- [ ] Add offset x and y to background layer
- [ ] On render apply offsets to the map and translate to screen changes
  - [ ] Tiles
  - [ ] Player
  - [ ] Monster

* TODO Function to translate screen coords to map coords

* TODO Entity to Tile collision detection
- [ ] Boundary collisions (is a tile passable)
  - Check the players map position and find the nearest tile in the tile map
  - If the tile is passable then do nothing
  - If not then reset offset-x and offset-y to 0

* TODO Multiple hit boxes per entity
- Entities should have body parts (multiple hit boxes)
- Body parts have a hitbox and are checked during collision detection
* TODO Test with simulation
Makes a series of state changes to the game and returns the end state once all steps are completed
Can be used for testing behavior visually and with real results
- [ ] Record game state
- [ ] Playback game state

* TODO Sprite animation rendering
- Fixed timestep animation?
  Each frame ticks the next frame in an animation
- Action list animation?
  This would allow the cancellation of an animation easily. Say a player is attacking and then get's hit halfway through the animation, could cancel the animation and start the hit animation
* TODO [#A] Sound system
System that reads an entities action list and global action list and plays the sound
* TODO Make game-loop a function that takes in args for frame rate and main function to call
* TODO Draw ordering of entities to know which should be in front of what
* TODO When moving, keep the player in the center unless the border is < 1/2 the distance to the player then allow the player to move towards it
* TODO Inspect protocol
All game engine things must be inspectable, returning details about it's current state
