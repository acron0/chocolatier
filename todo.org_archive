#    -*- mode: org -*-


Archived entries from file /Users/alexkehayias/Dropbox/Private/Clojure/chocolatier/todo.org


* TODO Version 0.2.0 [2/8]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:22
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: TODO
:END:
- [X] Update to version of clojurescipt and Austin plugin
- [ ] Sound system
- [ ] Tile collision
- [ ] Map to Screen coords
- [ ] Text rendering component
- [-] Optimization
  - [ ] Batch render sprites
    Move sprites to a new display object group and render all at once
  - [ ] Reducers?
    Investigate translating the game state transformations of systems and components as one giant reduction
  - [X] core.async to run systems async when marked as async-able
    - This turned out to be a very slow idea since just about everything so far is cpu bound
- [ ] Game loop macro
- [X] Helper macros/functions for declaring the game state
  - [X] Initialize state
  - [X] Initialize components
  - [X] Initialize entities
    - Subscribe events
    - Init component state

* DONE Should be able to create a sprite without an animation component <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 16:04]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Doesn't make sense that currently you need to make an animation component for something that doesn't animate
- [X] Update render-sprite to check for a moveable state before attempting to set a position
  - This means a sprite does not require a moveable component either
- [X] Update mk-sprite! to optionally take a frame this will force the rendering

* DONE Decouple movement offset from the controllable component <2015-12-25 Fri>
CLOSED: [2015-12-25 Fri 21:38]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Make the move component figure out to what rate the entity should move (offset)

* DONE Certain actions should be in addition to movement <2015-12-25 Fri>
CLOSED: [2015-12-25 Fri 18:00]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
i.e Moving in addition to certain attacks such as fireball and walking

* DONE Add text with the damage taken when an entity gets hit <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 17:26]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Show red text with the hit amount taken
- Fade out after a short duration
- Should follow the entity

* DONE Text rendering to sprites <2015-12-27 Sun>
CLOSED: [2015-12-27 Sun 15:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Move sprites to a separate place instead of component state?
  - This would eliminate the coupling of multiple components that need to alter the sprite from having to know about each other
  - Would not need to be animateable to have a position
- Should there be a sprite component, position component, animation component?
  - Sprite component would do all the altering at the same time on the sprite
  - Sprite would only need to read the position component, animation component to know what to do
- [X] Create a text component
  - Initial state takes some text
  - Must be created with a position component
  - Don't want a text-movement system

* DONE Add diagonal attack <2015-12-13 Sun>
CLOSED: [2015-12-27 Sun 13:11]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Version 0.1.0 [3/3]                                          :release:
CLOSED: [2015-01-18 Sun 20:55]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
** DONE Core [2/2]
CLOSED: [2014-11-15 Sat 11:27]
- [X] Browser repl
- [X] Centralized logging
** DONE Scenes State Components Entities Systems [5/5]
CLOSED: [2014-11-22 Sat 11:35]
- [X] Scenes (collection of systems)
- [X] Systems (collection of component functions)
- [X] Entities (UIDs with collection of component IDs)
- [X] State (nested hashmap representing scene state)
- [X] Messaging (Event bus for sending and receiving messages between systems)
** DONE Systems/Components [8/8]
CLOSED: [2015-01-18 Sun 13:52]
- [X] Movement
- [X] Circle collision detection
- [X] Rendering
- [X] User input
- [X] Tile mapping
- [X] Debug layer (collision circles)
- [X] Replay game state (go back to old game state on the fly)
- [X] Animations (sprites)

* DONE Add diagonal movement
CLOSED: [2015-12-13 Sun 18:32]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Static lookups for component and system function calls
CLOSED: [2015-07-11 Sat 21:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- What if we just wrap all the higher order fns with defs?
- What if at the time of wiring we def everything or stick them the game state in a deftype?
  - engine.core/mk-game-state
  - Maybe ces/mk-component should def the functions then return the fully qualified names in the state hashmap
  - We already have a static number keys for the game state and should not allow anything else
    - scenes
    - game
    - systems
    - components
    - entities
- This didn't end up helping since I found that these issues only show up when dynamically loading things from the repl

* DONE Audio component <2015-05-24 Sun>
CLOSED: [2015-05-24 Sun 17:12]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Talk for LispNYC <2015-08-16 Sun>
CLOSED: [2015-09-25 Fri 10:28] DEADLINE: <2015-09-08 Tue>
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Topics
  - Profiling
  - Functional game engine design
  - Performance optimization of ClojureScript
  - Embedded repl as a game mechanic

* DONE Add static fn analysis and pseudo name optimization for min build <2015-08-01 Sat>
CLOSED: [2015-11-01 Sun 19:32]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- As per this blog post http://swannodette.github.io/2015/03/16/optimizing-clojurescript-function-invocation/ we can get better call site optimization
- Need extern file to work with advanced Google Closure optimization i.e https://github.com/cljsjs/packages/blob/master/d3/resources/cljsjs/d3/common/d3.ext.js
- Alternatively, refer to external libs by string name only
  (let [yay ((goog.object.get js/window "yayQuery"))]
    ((goog.object.get yay "sayHello") ((goog.object.get yay "getMessage"))))
- [ ] Extern file for pixijs
- [ ] Extern file for howlerjs
- [ ] Update project.clj under cljsbuild profile "min" build
  ;; Statically analyze function arrities
  :static true
  ;; Flatten namespace conventions into
  ;; names instead of nested objects
  :pseudo-names true

* DONE Spatial index for help reduce number of collision detections <2015-11-15 Sun>
CLOSED: [2015-11-15 Sun 22:12]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Benchmarks http://0fps.net/2015/01/23/collision-detection-part-3-benchmarks/
- Good r-tree lib https://github.com/mourner/rbush

* DONE Remove circle radius from player and enemy entity constructor <2015-11-22 Sun>
CLOSED: [2015-11-27 Fri 15:16]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Optimize update-spatial-index <2015-11-15 Sun>
CLOSED: [2015-11-16 Mon 22:18]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- According to profiler it's really slow
- Seems like the root cause is get-multi-component-state function that only gets realized inside of update-spatial-index

* DONE Optimize collision detection as it seems to be the slowest system <2015-11-08 Sun>
CLOSED: [2015-11-15 Sun 22:11]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Optimize the ces framework
CLOSED: [2015-11-08 Sun 20:23]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- When you double the number of entities the framerate drops nearly in half
- AI system/component showcases this the best, removing it increases the framerate a ton
- How can we reduce the number of changes to the global state?
- Size of the state hashmap is not the problem
  Adding initial state of (reduce into {} (map hash-map (range 10000) (range 10000))) has no slow down even with 10000 additional keys
- Event messages the biggest issue?
  - Every time a system runs it can generate up to n number of state changes where n is the number of events emitted
  - Make the event queue a mutable object
    - Was super slow, see mutable-queue branch
  - Every time an event is emitted, mutate the queue instead of rewriting the state hashmap
  - Make the queue a hashmap instead of a hashmap and an array
    - Each message has it's own unique ID
    - To get all messages at a selector, iterate through all keys at that point
    - Only once per game loop will we need to return a new game state for the sake of events (when the queues are cleared)
  - Flatten the keys for events and
  - Batch all the events in one shot at the end of the system call\

* DONE Systems should only be running one component function instead of a collection <2015-08-02 Sun>
CLOSED: [2015-11-08 Sun 20:22]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Refactor events <2015-08-02 Sun>
CLOSED: [2015-08-16 Sun 18:23]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Too slow
  Profiler shows bottleneck in emit-events and get-events
- Currently implemented as a nested hashmap of sequences of event hashmaps
- [X] Remove nesting?
  - Want a way to select what we need in one shot withouth walking a nested data structure
  - Should reduce time for getting events and emitting events if there is no nesting
  - Overload the names of the event to prevent nesting?
  - Do we need to give up hierarchical event subscriptions? Are they useful?
  - Removed nesting and that improves by a few frames
- [ ] Remove events in favor of directly querying component state
  - Would couple components implicitely
    - Is there a way to explicitely make the dependencies between entities and components states?
  - Instead of inbox, maybe replace with a read only queryable component state?
    - If you have direct access to objects then they can be mutated by something other than the component that owns the state
    - Components shouldn't have access to game meta state only component state

- [-] Reduce the usage of events
  - Movement/collision/animation is the challenging part to decouple
    :player1
    controllable -- moveable -- collision -- position -- animation

    :enemy1
    ai -- moveable -- collision -- position -- animation

  - [ ] Make a new component called position which is based on the movement and collision component states
    - [ ] Player1 movement component should query the input state and set the desired movement
    - [ ] Position component
    - [ ] For enemies, position component to set the offsets
    - [ ] Animateable queries position and action component state

  - [X] Use state machines instead of requiring a message to be present
    Example: Only send an event if something has changed instead of requiring a message every frame
    - [X] Update controllable/react-to-input to only emit an event if the state has changed
    - [X] Update moveable to only emit when movement has changed

* DONE Refactor component function args to all be a map instead of positional args <2015-08-16 Sun>
CLOSED: [2015-11-08 Sun 20:19]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- It would be hard to had additional functionality to component functions if we have to worry about breaking call signature changes
- [X] Change args to all component functions to be a single hashmap
- [ ] Rename :args-fn to something more appropriate

* DONE Fix V8 optimization bailout in ces/iter-entities <2015-07-26 Sun>
CLOSED: [2015-08-01 Sat 11:56]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Error is "bad value context for arguments value"
- https://github.com/bevry/taskgroup/issues/12#issue-23512231
- https://code.google.com/p/v8/issues/detail?id=3037
- Fixed by making it a two arrity function

* DONE Clean up usage of apply in mk-component-fn <2015-07-25 Sat>
CLOSED: [2015-07-25 Sat 19:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE mk-event should take a vector of selectors instead of varargs <2015-07-25 Sat>
CLOSED: [2015-07-25 Sat 19:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Benchmarks for the engine <2015-04-04 Sat>
CLOSED: [2015-04-04 Sat 13:29]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Use this to test any pervasive changes to the rest of the framework related to performance
- Use simple-benchmark which is built in which shows the running time for a function over n iterations
- [X] Calculate the number of frames per second the engine can do
- [X] Add best of calculation
- [X] Add basic stats

* DONE Remove use of filter to get a list of entities that have a component
CLOSED: [2015-04-04 Sat 14:41]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Currently stored as :entitiy -> [:c1 :c2]
- Reverse it so that when an entity is created it is indexed to a direct lookup path i.e :component [:e1 :e2]
- Can use keys on :state -> :c1 to get all entities in one shot without a fitler then map

* DONE Update to latest pixijs <2015-05-03 Sun>
CLOSED: [2015-05-03 Sun 11:50]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Update to v3
- Add as a submodule

* DONE Add stats.js to track frame rates
CLOSED: [2015-05-03 Sun 17:08]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
https://github.com/mrdoob/stats.js

* DONE Eliminate unoptimized function calls in v8 due to needing dynamic lookup
CLOSED: [2015-07-11 Sat 21:38]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Profiler says all the inner functions can not be optimized because the require a dynamic lookup and therefore can not be inlined by v8
- [X] Use macros to define a new function for each system/component instead of anonymous functions
- See branch defcomponent, didn't pan out as this isn't actually an issue on the first run

* DONE FIX debuggable collision circle overlay is not centered correctly
CLOSED: [2015-05-03 Sun 12:38]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Game loop helpers <2015-02-22 Sun>
CLOSED: [2015-03-07 Sat 21:22]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Make it easier to set up a game loop and constructing inital state
- [X] Game state helper
  Declare the function for a system, components and it will auto call mk-system/mk-component on them
- [X] Game loop helper

* DONE Update to latest version of austin and cljs <2015-02-21 Sat>
CLOSED: [2015-02-21 Sat 11:19]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Austin 1.6 has issues so need to use version 1.7-SNAPSHOT or the repl doesn't work
- Had to update lein cljsbuild because it was to old to work with later cljs
- Now using the cljs required by core async latest

* DONE Add pixijs as a foreign dependency <2015-03-29 Sun>
CLOSED: [2015-11-08 Sun 20:23]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- https://github.com/clojure/clojurescript/wiki/Foreign-Dependencies
- No need to do this with externs

* DONE Live reloading during running game loop for any function change
CLOSED: [2015-11-27 Fri 15:17]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Looks like when the game loop is running the functions are immutable except in the case of multimethods so re evaluating a function does not guarantee that it will be used by the game engine.
- Update the lookups of system/component fns inside the game loop to lookup by reference rather than by value??
- This appears to work now <2015-11-27 Fri>

* DONE Benchmark for game engine performance <2015-03-07 Sat>
CLOSED: [2015-11-27 Fri 15:17]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Use it to compare different implementations of the core game functions and optimize
- See chocolatier.engine.benchmarks for more

* DONE Use transients for local mutability <2015-02-01 Sun>
CLOSED: [2015-11-27 Fri 15:18]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Figure out where we can use transients instead of normal hashmap operations
  - Systems?
  - Components?
  - CES operations?
- [X] Change all systems to use transients
- [ ] Change collision detection to use transients of js arrays to do collision detection
  - No longer need to do this since implementing rbush for r-trees
- Doesn't seem to help that much, may revisit this <2015-11-27 Fri>

* DONE "Threads" using core.async to run systems async based on deps <2015-02-21 Sat>
CLOSED: [2015-02-22 Sun 15:50]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Branch: async-systems
- Example:
  - Given dependency tree [[a b] [a c] [c d]]
  - Run in this order where a vector denotes async operation [a, [b c], d]
- Probably need to cache this when game loop is initialized and recalc anytime a new system is added/removed
- Turned out to be much slower due to overhead of core.async since these are all cpu bound tasks there is no benefit to async'ing them

* DONE Add direction to movement and animation so you remain in that direction when standing <2015-01-18 Sun>
CLOSED: [2015-01-25 Sun 12:36]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Add stand as an action if not walking to Controllable
- [X] FIX animation stack keeps growing
  Need to remove the last action if a new one comes in

* DONE Add attack animation <2015-01-25 Sun>
CLOSED: [2015-01-25 Sun 20:49]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Animation system <2015-01-17 Sat>
CLOSED: [2015-01-18 Sun 13:52]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- State machine for representing animations
- Hold on to the last state so that after an animation it goes back to what it was in
- State
  - Animation state key i.e. :walking :running
  - Frame number (for sprite sheet)
  - Dimensions of sprite sheet i.e width/height/frame-width/frame-height
- Abstraction for specifying an animation
- Key frame animation?
- Multi part sprites?
- [X] Renderable system should only call the stage render code
- [X] Move sprite updating based on movement to the animateable component
- [X] Can change to animateable system rather than renderable so all can share sprite stuff in one place. It only reacts to events so it's ok
  - Handles changes to sprites based on events including movement, animation, image swaps
- [X] Fix collision detection to use move component for position state or to get all info from the incoming event msg
- [X] Hold the hit zone info about an entity in the collidable component state
- [X] Position information should be held by the move component

* DONE Fix replay not working when pressing :B <2015-01-03 Sat>
CLOSED: [2015-01-03 Sat 17:41]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Looks like new events evaluation causes replay to not work
- One of the systems is clearing out messages before it can make it to the replay system
- Systems were seqing over a hashmap which is not guaranteed to have order

* DONE Implement snapshots of game state and function to reload it <2014-12-07 Sun>
CLOSED: [2014-12-07 Sun 22:11]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Take a copy of game state every n seconds and stick in vector
- Add an input control for a button to control stepping backward
- Thumbnail???? Would be super cool to render a mini image

* DONE Finish up selectors for events <2014-12-13 Sat>
CLOSED: [2014-12-13 Sat 21:11]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
If there are keys instead of a seq then recursively concat all the messages down the tree

* DONE Update subscription calls to filter out messages properly using the passed in boolean function for determining if an even should go into an inbox
CLOSED: [2014-11-23 Sun 11:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Behavior component (for demo) <2014-11-22 Sat>
CLOSED: [2014-11-23 Sun 11:37]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Implement an AI behavior for entities with the :ai component
- Chose to go towards the player on each turn

* DONE Collision detection takes too much cpu time <2014-11-22 Sat>
CLOSED: [2014-11-23 Sun 21:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Profiling shows 70% of all cpu time each trip through the game loop
- Alternatives
  - Perform the lookup in one shot for all entities
  - Sort by x, y, use x y to figure out which entities you should check against
  - Spatial grid, divide up all the entities into a 2D grid once per frame, only compare entities in the same frame
  - Cache the collision checks as you don't need to compare every entity in reverse A->B AND B->A

* DONE Add spatial grid system <2014-11-23 Sun>
CLOSED: [2014-11-23 Sun 21:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Fan out messages takes too much cpu time <2014-11-22 Sat>
CLOSED: [2014-11-28 Fri 19:32]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Profiling shows 20% of cpu time each trip through the game loop
- There was a message leak that was piling up in the queue
- Make event subscriptions opt in not opt out
- Subscribe to an event from someone to a specific ID
- Make broadcast subscriptions optional?
- Subscribe an entity to a specific event
  Subscribe a component?
  Subscribe an entity?
  What does the entity get in their inbox? All messages?
  When do you remove messages from inbox?
  Need better parsing of event messages
- Resulted in 2x framerate from 8-10 to 18-20

  Put the messages in a hashmap instead of a list
  {:events {:subscriptions {}
            :queue {:<event-id>
                     {:<source-id> [{:event-id :<event-id> :from :<from-entity> :msg <message>}]}}}}
  Subscribing to broadcast events is the concatenation of all values of keys nested in the event id
  A subscribed event is id -> from a specific entity

  Don't do a fan out as part of each system only check the events queue and make a lazy sequence that gets included as the inbox argument
  The event-system should clear out the event queue, handle new subscriptions/un-subscribes

* DONE Tiled tile map support <2014-12-07 Sun>
CLOSED: [2014-12-07 Sun 20:55]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Create a system for using tilemaps defined by Tiled
- [X] Load tile set image
- [X] Load json
- [X] Translate spec into tile set
  https://github.com/bjorn/tiled/wiki/TMX-Map-Format#tileset
  - imageheight, imagewidth, tileheight, tilewidth, tileproperties
  - The spec for the tiles is in data.layers[0].data and is a one dimensional array with numbers representing the tile to use
  - To get the x, y of the tile
    - number * tile width
    - by the width of the image divided by
- [ ] Update tile system to display it
  Needs to read the offsets of the tiles to shift the tileset image by x and y

* DONE Update documentation about event system <2015-01-03 Sat>
CLOSED: [2015-01-03 Sat 17:55]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Change game loop to wrap state in an atom so it can be inspected <2014-11-15 Sat>
CLOSED: [2014-11-15 Sat 17:34]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Fix controls does not register up and down <2014-11-16 Sun>
CLOSED: [2014-11-16 Sun 21:10]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Pixijs wrapper <2014-11-16 Sun>
CLOSED: [2014-11-16 Sun 17:14]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Hide all of the javascript interop to keep the api clean. Consider a polymorphic layer so that a different renderer can be swapped in.

* DONE [#A] Port existing components and systems to new CES refactor <2014-09-21 Sun> :core:
CLOSED: [2014-11-22 Sat 14:48]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- core
  - [X] game-loop
- systems
  - [X] render
  - [X] input
    Collects system input and stores it every loop
  - [X] user control
    Does something with the user input
  - [X] tiling
  - [X] movement
    Should handle reconciling user input to changes not sure how this is different than user control
    - It's different because without it you will not be able to check if you should make the next move resulting in a loop where you get stuck because you are always colliding
    - Can the entity make it's next move?
    - Should take a message from input about changes and move if there is not also a message for a collision
  - [X] collision detection
    Check against all entities to see if they are colliding
  - [X] debug layer (draw circles around entities)
    - Turn red when a message collision message is present in the inbox
    - Not sure how to do this without coupling renderable, collidable, and debuggable
    - Make the selector for entities check multiple component-ids to get entity ids
    - Make custom component state parsing function
  - [X] Repl changing of game state via state atom

* DONE [#A] Cross system/component communication [7/7] <2014-10-12 Sun> :core:
CLOSED: [2014-11-15 Sat 17:03]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Need a way to share information between systems and components
- [X] Component/Entity events mailbox
  - Each component should get access to it by default (can be nil)
  - Example (send-msg state :from-component-id :from-entity-id msg)
  - Messages are async, no response is given, all info must be in the message
- [X] Need a system to clear out messages
- [X] Fan out messages to all subscriber inboxes
- Read only component state if it is not yours
- [X] Default component functions should also take in an inbox as an argument by default
- [X] Provide a way of emitting event from any component by passing it in as an arg
  - Currently, the component function returns a hashmap which will be merged in to the game state
  - We also need to provide a way of conveying that an event(s) should be emitted
  - Component functions can output 1 or 2 items
    - If it's 1 item then it's the component state
    - If it's 2 items then it is component state and events
    - You can never just return events
- [X] Update game system fns now that component fns return updated game state rather than component state
  No longer need to use deep-merge which is recursive and costly. Instead use iter-fns on the collection of component fns in a system
- [X] Clear events inboxes after the system runs each component function

* DONE mk-component-fn should allow custom argument parsing function AND output wrapper <2014-10-12 Sun>
CLOSED: [2014-10-12 Sun 19:25]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Currently, passing in a args-fn to mk-component-fn DOES NOT wrap the output of the function into a mergeable hashmap. The caller must handle it in the function. This is confusing since it is handled automatically if you don't pass in an args-fn.
- 9 times out of 10 you will want to automatically merge in component state
- This will get even harder to manage yourself if we have to handle merging of events
- Solution:
  - Allow optional argument parsing functions
    1. Calling the function with the desired arguments
    2. Wrapping the output of the function into something mergeable

* DONE [#A] Replace ces/deep-merge in systems with iter-fns since each component by default calls ces/update-component-state-and-events which returns an updated global state
CLOSED: [2014-11-16 Sun 17:24]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Make assertions in component functions to fail faster <2014-11-15 Sat>
CLOSED: [2014-11-15 Sat 13:13]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Throw an error if output is not a 2 item collection
- [X] Throw an error if component state or inbox or event-fn etc are nil

* DONE Change component state to not live in the component but under the :state key <2014-10-12 Sun>
CLOSED: [2014-10-12 Sun 17:20]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Validate component functions exist when called
CLOSED: [2014-10-04 Sat 22:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Validate system functions exist when called
CLOSED: [2014-10-04 Sat 22:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Scenes
CLOSED: [2014-09-21 Sun 16:23]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
A list of systems and a encapsulated state that defines a different element of a game such as a menu or mini game

* DONE Polymorphic component functions
CLOSED: [2014-10-03 Fri 22:27]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- An entity should be able to implement it's own function to satisfy a component
- Multimethod with a default should work perfectly here
- Example
  Dispatch on the entity-id
  (defn default-update-sprite
    "Update the entities sprite"
    [component-state entity-id]
    (let [sprite (:sprite component-state)]
      ;; Mutate the x and y position
      (set! (.-position.x sprite) (:pos-x component-state))
      (set! (.-position.y sprite) (:pos-y component-state))
      component-state))

  (defmulti update-sprite
    (fn [component-state entity-id] entity-id)

  (defmethod update-sprite :default [component-state entity-id] default-update-sprite)

* DONE CES refactor to make it more functional <2014-07-06 Sun>
CLOSED: [2014-09-21 Sun 21:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Refactor to use a state hashmap which gets passed to all systems
- [X] Add tests for ces functions

* DONE Require state dependencies
CLOSED: [2014-10-04 Sat 19:18]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
This is probably too restrictive. Instead allow an arguments function that parses state and is applied to the component function.
- Specify your state dependencies in your component function
- Call your component function with the state in the order specified
- Return value must be a vector of all state to be merged in
- Example:
  (defcomponent stuff [input stage me]
    (my-fn input stage me))
  Calls a fn to get deps out of state
  Takes the return result and makes it merg-able with global state

* DONE Bring back dynamic eval of the game loop since it is no longer an atom
CLOSED: [2014-10-04 Sat 00:39]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Need a way to re-eval systems/components/etc in a repl and have the changes go
defmulti seems to work for that
Components using defmulti work with reload
There was a bug that was causing the loop to exit early thus reload wasn't working

* DONE Systems should be by ID reference to a scene not a direct reference <2014-09-21 Sun>
CLOSED: [2014-09-21 Sun 17:21]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
When running a scene it should lookup by keyword the reference to the system fn

* DONE defentity <2014-05-04 Sun>
CLOSED: [2014-05-04 Sun 12:51]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Returns a defrecord with a hashmap of component Protocols and functions
- Reads :fields metadata of protocol and creates a list of all fields that will be the record's state

* DONE defcomponent <2014-05-04 Sun>
CLOSED: [2014-05-04 Sun 12:51]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Creates a protocol
- Takes a name, state (hashmap of fields), and methods
- Returns a protocol with metadata about it's fields

* DONE Move all state to it's own ns
CLOSED: [2014-01-18 Sat 17:33] <2014-01-18 Sat>
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Implement systems that are run on every step through the game loop <2014-01-18 Sat>
CLOSED: [2014-01-18 Sat 18:52]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE FIX have to manually evaluate the systems.core/render/tick, input <2014-01-18 Sat>
CLOSED: [2014-01-19 Sun 16:36]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
This was due to issues with the move of all state to engine.state ns and not recompiling the js. The smoking gun was that `game` was defined in engine.core not `s/game`

* DONE Basic keyboard WASD and directional arrow movement <2014-01-19 Sun>
CLOSED: [2014-01-19 Sun 17:31]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Implement fixed timestep gameploop <2014-01-20 Mon>
CLOSED: [2014-01-20 Mon 00:08]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
- time between game loop calls

* DONE Fix pausing game breaks the game loop <2014-01-20 Mon>
CLOSED: [2014-01-20 Mon 00:22]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- need to request the recur the loop

* DONE Make render perform the position changes <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 16:00]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
to the sprite based on the current values of the record

* DONE Tiles
CLOSED: [2014-01-26 Sun 16:00]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Tile maps <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 21:41]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Change state to tile-map which is a hashmap with meta about the map and a list of Tile objects

* DONE Error thrown when resetting game
CLOSED: [2014-02-10 Mon 02:17]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Extra parenths in the callback would lead to a function call of the result of start-gamey
Uncaught TypeError: Object #<HTMLBodyElement> has no method 'call' VM491:2
(anonymous function) VM491:2
(anonymous function) VM487:10
cljs.core.Atom.cljs$core$IWatchable$_notify_watches$arity$3 core.cljs:7038
cljs.core._notify_watches core.cljs:340
cljs.core.reset_BANG_ core.cljs:7074
d core.cljs:7088
a core.cljs:7091
game_loop VM484:16
(anonymous function)

* DONE Batch translate by offset for a collection of tiles
CLOSED: [2014-02-10 Mon 02:02]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE FIX dynamic loading of entities doesn't take effect <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 16:56]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Now that we perform state changes that produce a new record each transaction, changes to underlying protocols or records takes place immediately!

* DONE FIX multiple reset-games makes the input move double as fast each time until the canvas is removed <2014-01-26 Sun>
CLOSED: [2014-01-26 Sun 21:36]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Stop flag is not being caught in the game loop
Add a watcher and callback to reset the game

* DONE Move tiles based on the player's position <2014-02-07 Fri>
CLOSED: [2014-02-16 Sun 22:27]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Player needs to have a map position coordinate
- [X] Create a new component BackgroundLayer which is used by Tilemap to adjust it's tiles based on players position
- [X] UserInput should set the direction and the x y offset based on velocity

* DONE FIX Error thrown by the callback watcher on reset-game! <2014-01-26 Sun>
CLOSED: [2014-02-16 Sun 22:31]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE FIX initial reset-game! does not work <2014-02-16 Sun>
CLOSED: [2014-03-02 Sun 15:07]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- systems is not loaded on engine.core load
  - This was due to compiled js being used instead
- the first time and requires calling start-game!
- there is a race condition where the renderer starts before the window has a width or height causing an error when pixijs renderer is called
- Need to load the asset for the tile background using an asset loader
  loader = new PIXI.AssetLoader(["resources/bg-far.png","resources/bg-mid.png"]);
  loader.onComplete = onAssetsLoaded
  loader.load();
  Then one can simply wrap the code into the onAssetsLoaded function

* DONE Move tiles into the game engine <2014-01-26 Sun>
CLOSED: [2014-03-02 Sun 15:19]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Each entity that is collidable needs to have a hit box radius
CLOSED: [2014-03-09 Sun 19:12]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Fix directory structure for cljs is not conventional <2014-03-14 Fri>
CLOSED: [2014-03-14 Fri 17:09]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Need a chocolatier dir

* DONE Debug layer needs to be moved to engine/state so that it can be coordinated during resets <2014-03-22 Sat>
CLOSED: [2014-03-22 Sat 20:01]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Add a watches namespace for tools to debug changes to state <2014-04-06 Sun>
CLOSED: [2014-04-06 Sun 14:27]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Collision detection for player causes the player to not be able to move (always colliding) <2014-03-14 Fri>
CLOSED: [2014-04-12 Sat 20:32]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Prevent movement if the result of the move is a collision
- The player is able to move such that the circles are overlapping
  - Maybe the collision detection is wrong?
    - The formula seems to work
    chocolatier.engine.systems.collision> (collision? 352 220 20 322 186 30)
    true
    chocolatier.engine.systems.collision> (collision? 352 220 20 320 184 30)
    true
    chocolatier.engine.systems.collision> (collision? 352 220 20 317 181 30)
    false
  - Maybe the addition of the offset x/y is not being checked properly?
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 306 206 VM8682:9
    DEBUG: After offset 306 206 VM8682:9
    # THIS STARTS THE MOVE TOWARDS COLLISION
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 356 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    # THIS SHOULD HAVE RELEASED IT
    DEBUG: State changed :input-debug {:A "off"} VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    # Even after no offsets are being applied we still have a collision!
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206 VM8682:9
    DEBUG: Collision detected between :player and :monster VM8682:9
    DEBUG: Before offset 352 220 VM8682:9
    DEBUG: After offset 352 220 VM8682:9
    DEBUG: Before offset 310 206 VM8682:9
    DEBUG: After offset 310 206
  - Maybe the order of the systems is wrong?
    - Moved movement phase to right before the collision detection
    - Render phase now applies the offsets calculated and applies them to the sprite
  - !!! Player has an offset even though it's screen position will not change
    - Monster also has an offset based on the player's offset
    - [X] Use a global screen offset when user input comes in to control
    - [X] Other entities then use the screen offset for their own movement and screen position
    - Movement stop on collision works when both entities have collision detection on and the player is passed in to the collision check without any offsets
    - Tiling works correctly when offsetst are removed but the monster moves with the player equally
  - Debug log 1:
    DEBUG: State changed :input
        :W off -> on VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 328 -> 323
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 333 -> 328
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :monster
        :screen-y 338 -> 333
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :player 361 408 30 and :monster 365 343 40 VM1052:9
    DEBUG: State changed :global
        :offset-y 5 -> 0 VM1052:9
    DEBUG: Collision detected between :monster 365 343 40 and :player 361 408 30 VM1052:9
    DEBUG: State changed :monster
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :player

     VM1052:9
    DEBUG: State changed :monster

     VM1052:9
    DEBUG: State changed :player
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :global
        :offset-y 0 -> 5 VM1052:9
    DEBUG: State changed :monster
        :offset-y 5 -> 0 VM1052:9
    DEBUG: State changed :player
  - The input handler can be on constantly and the user input step takes the latest value of the atom during a run through the game loop
  - Player was able to perform an illegal move
    From
    (collision? 361 250 30 288 250 40)
    To
    (collision? 361 250 30 292 250 40)
    Even though they were colliding
- Player and monster are sharing the same offset-x and why which will negate each other during collision detection because the detector applies the offsets before checking. This makes it impossible to move away from a collision
- How movement works
  1. User input
  2. Player adds an offset based on user input
  3. Monster adds an offset based on the players offset
  4. Collision detection runs
  5. Offsets are removed if there is a collision
  6. Sprite positions updated based on applying offsets to screen position
- FIXED by removing offset of the player!

* DONE Entity to entity collision detection <2014-03-09 Sun>
CLOSED: [2014-04-12 Sat 20:38]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Collisions should be a core system run before movement
- [X] Entity collisions
  - Collision based on velocity and direction
  - Compare all entities to each other
- [X] Draw a circle for debugging in the render function
  chocolatier.engine.systems.debug

* DONE Change entities state to a hashmap instead of a vector <2014-04-06 Sun>
CLOSED: [2014-04-12 Sat 20:44]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Center hit zone to the middle of the player sprite <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:01]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Make entity height and width a value on Player and Monster <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:42]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Update entity-collision? fn to use that instead of getting a sprite attribute. This will make it easier to test just by using a hashmap instead of a hashmap with a sprite object

* DONE Collision detection is for too far away <2014-04-12 Sat>
CLOSED: [2014-04-12 Sat 21:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
After adding height and width to entities, the collision is detected too early
Wrong value of radius being used in collision detection

* Profiling notes
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:END:
- In the chrome js console profiler:
  - "self" is how much time was spent doing work directly in that function.
  - "total" is how much time was spent in that function, and in the functions it called.
** Profiling <2015-07-19 Sun>
- AI system profile
  - apply is 45% of the time spent
  - update-component-state-and-events 35%
    - Looks like emit events is the culprite with update-in happening many times
- Broad collision system
  - entities-with-multi-components 40% of time
  - mk-spatial-grid is 52% of time, looks like the group-by is inefficient
- Narrow collision system
  - Pretty small amount of time spent there
** Profiling <2015-07-25 Sat>
- narrow-collision detection takes 25%
  - check-collsions appears to be the culprit with 20% time spent there
- get-subscribed-events takes 22% of the overall profiled time
  - usage of mapcat appears to be the culprit with 20% time spent there
** Profiling <2015-08-01 Sat>
- Only looked at 2 systems movement and ai
- Major bottlenecks
  - apply (unoptimized by v8) in component-fn-body
  - emit-events reduce is spending lots of time and number of function calls will grow linearly with each entity added
  - get-events spends all it's time with get-in

* Live demo <2014-12-10 Wed>
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:END:
Want to show how nice it is getting quick feedback loops and adding new features to the game
- Start a game from scratch and build it up
- Show how to inspect game state
- Show what it's like to work with
- Add a new system or feature
- Update an existing system on the fly

* Macros
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:23
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:END:
** TODO defsystem
Takes a scene state and handler fn and returns a function
** TODO defgame
Takes a collection of scenes where the default scene is the first one
Implements a fixed time step game loop
Loads the stage (rendering engine)
What happens if there is more than one defgame?

** TODO defscene
A collection of systems and initial state for managing the systems. Returns an atom with a hashmap representing the scene state. Returns a hashmap of functions for managing the scene such as state resets
** TODO defentity does not work due to issues with eval from another ns
 - Metadata on def does not work in clojurescript
 - Eval inside a macro resolving a symbol from another ns does not work
 - Loading the caller's ns does not work https://github.com/teropa/hiccups/blob/master/src/clj/hiccups/runtime.clj
 - [ ] Bind to another ns in the macro http://stackoverflow.com/questions/7684656/clojure-eval-code-in-different-namespace

** TODO defaction
Creates a vector of actions used by an action list
** TODO deflevel
Defines a new level for the game
Takes a list of assets to load, which world map, game scripts to load etc

* DONE System for injecting adding/removing entities from the game state while game loop is running
CLOSED: [2016-01-10 Sun 12:24]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:24
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* TODO Wrap pixi sprite calls into something more friendly
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:25
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: TODO
:END:

* TODO Action list
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:25
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: TODO
:END:

* DONE Entity message passing
CLOSED: [2016-01-10 Sun 12:25]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:25
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Pass a message from one entity to another and process the list of messages
Processing the list of messages can result in generating actions on the action list

* TODO Debug layer for spatial grid
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:25
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: TODO
:END:
Show grid lines with numbers based on the spatial grid of that frame

* DONE Collision detection <2014-12-07 Sun>
CLOSED: [2016-01-10 Sun 12:28]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:28
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
It's not working due to broad collision detection not accounting for mass of entity and not factoring in intended movement

* TODO Background rendering jumps using fixed timestep gameloop [/] <2014-04-05 Sat>
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:28
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: TODO
:END:
- Fix timestep loop causes rendering issues
  - When you put the render system in iter-systems the movement is correct
  - When it's not you get inconsistencies in the rendering where certain parts are moved in weird ways like the background or monster
because render gets called outside of the systems step loop
- Tiles are moving but the Monster is

** TODO Re-implement fixed timestep loop where render is outside of the timestep loop
Line 73 in engine.core

** TODO Add a new system for writing changes to screen coords after all systems complete
This way the render step is only for updating draw code and we don't have to be concerned with offsets

* DONE Add a combat system for attacking between entities [11/12] <2015-11-28 Sat>
CLOSED: [2016-01-10 Sun 12:33]
:PROPERTIES:
:ARCHIVE_TIME: 2016-01-10 Sun 12:33
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Combat system
- [X] Meta system [2/2]
  Dynamically add/remove/change the game state by listening to events on the :meta where the message implements the specs for :entity
  - [X] Add entity
  - [X] Remove entity
- [X] TTL system/component
  When the duration of an entity exceeds the counter, emit an event to remove itself from the game
- [X] Attack component [2/2]
  - [X] Attack throttling with configurable cooldowns
  - [X] Emit events to :meta to create an attack entity
- [X] Implement cleanup functions for components
- [X] Update animateable component to remove the sprite from the stage using a :cleanup-fn
- [X] Update collision system to take into account offset-x/y
  Increase the size of the hit box to where the entity will be next frame this will mean all area the entity will pass through will be included for collision detection
- [X] Add damage system and hitpoint component
  - [X] Emit damage events when colliding with an entity prefixed by "attack"
  - [X] Emit an action event when colliding with an attack
  - Update hitpoints
  - [X] If hitpoints falls to 0 then emit a message to show the destro animation then remove the entity
  - [X] Invinsibility period (cooldown of when they can take damage next)
- [X] FIX collisions with invisible bounding boxes?
  - When eliminating some enemies, end up colliding with nothing
- [X] Determine if it's attack collision if there is a damage attribute instead of overloading the entity-id
- [X] FIX cooldown requires a full cycle before it allows an attack

* DONE Add type hints before if statements to avoid extra checking
CLOSED: [2016-03-03 Thu 21:41]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:42
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
(if ^boolean (pred v) ...)

* DONE Refactor system functions
CLOSED: [2016-03-06 Sun 15:42]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:42
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- [X] Systems should provide the lens for component functions instead of wrapping all the component functions
- [X] Update all the component state in one shot instead of updating the state for each entity->component
  - Assumes there can be no inter system component state access or message passing
- [X] Figure out how to handle events
  Accumulate it using a transient and then emit it later
- [X] Update mk-system with less boilerplate for creating a system and an accompanying component
  - Component's are ALWAYS part of a system, a system does not always work on a component
  - Avoid errors like not having a component function that is called by a system function
  - Could present opportunities for optimization if we can guarantee the component fn is there
  - API
    - Custom system [:system :s1 my-system-fn]
    - System with component [:system :s2 :c1 my-component-fn]
- [X] Update benchmarks
- [X] Remove mk-component-fn if it's no longer used
- [X] Systems should still declare what components they work on so it's not hardcoded into the implementation
  - What about multiple components?
    - Example: Collision detection works on entities that have movement and collision
  - If they don't work on a component then idiomatically use "global"
- [X] Replace all args-fn with select-components
  - What about when you need some global state like input?
  - What if you need component state for a different entity?
- [X] Replace format-fn used by the ai system
  - Probably want a custom system instead
  - TODO need to remove the hardcoding of the component name
- [X] Update action rpg example
  - [X] Update any systems that do anything special to implement their own system fn
  - [X] Delete any systems that are generic
- [X] Update tests
  - [X] mk-system-fn
    - [X] Test events get emitted
    - [X] Test component state gets updated
  - [X] get-component-context
  - [X] get-subscribed-events

* DONE Create a reverse lookup for checking entities given a component label
CLOSED: [2016-02-27 Sat 15:48]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Currently, to get entities that have a component you would need to get all keys in that component's state which is not very intuitive
- There should be a way of looking up all the components an entity has
- There should be a way of looking up all entities for a given component
- The index should be a set to guarantee uniqueness

* DONE Explore the use the entity ID to handle polymorphism?
CLOSED: [2016-03-03 Thu 12:00]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Instead of entity IDs being labels they can be types
- If they are known types then we can make component fns which are protocol methods
- This would allow you to create per entity ID polymorphism, i.e player1, some boss, have different movement rules?
- Would need a macro that copies all the functionality of the Keyword class so it can still be used for looking up things in the game state
- Issues:
  - Dispatch of implementation would be per entity so if we want all enemies to share the same implementation would need a lot of copying
- Example:
  #+begin_src clojure
  (defprotocol Moveable
    (move [this component-state context]
      "Handle whether or not the entity should move"))

  (extend-type Player1
    Moveable
    (move [this component-state {:keys [inbox]}]
      (let [{:keys [pos-x pos-y move-rate direction]} component-state
            {new-direction :direction} (:msg (get-move-change-event inbox))
            collision? (collision-event? inbox)]
        (let [next-direction (or new-direction direction)
              [offset-x offset-y] (if collision?
                                    [0 0]
                                    (mapv #(* move-rate %)
                                          (direction->offset next-direction)))]
          (assoc component-state
                 :pos-x (- pos-x offset-x)
                 :pos-y (- pos-y offset-y)
                 :offset-x offset-x
                 :offset-y offset-y
                 :move-rate move-rate
                 :direction next-direction)))))
  #+end_src

* DONE Component state as defrecords perf improvement?
CLOSED: [2016-02-24 Wed 13:53]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Could also solve the validation problem so all keys are known up front
- In the benchmarks it didn't make a difference

* DONE Make component state mutable
CLOSED: [2016-02-24 Wed 16:48]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Same benefit if you use transient or a js-obj
- Tested in benchmarks js objects and transient hashmaps performed 40% better that persistent maps
- In the running game engine though there was not much of a difference in the overall frame rate
  See the flatten-state branch for more
- [ ] Don't return a new object, return the same one so we are not creating new data structures every time

* DONE Use reducer for events/get-subscribed-events
CLOSED: [2016-02-23 Tue 04:19]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Doesn't make any noticeable difference

* DONE Move event functions out of chocolatier.systems.events and into chocolatier.events
CLOSED: [2016-02-23 Tue 04:51]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Rename ces namespace to ecs
CLOSED: [2016-02-23 Tue 05:31]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:

* DONE Text damage rendering to the top left corner
CLOSED: [2016-02-14 Sun 11:03]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- :cleanup-fn is not being called when an entity is being removed from the scene
- Can we make that automatically declared by the component instead of in the wiring up?

* DONE Inspector
CLOSED: [2016-02-23 Tue 19:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Show the component states of an entity and be able to adjust it
- Implement as dom elements
- [X] Make game-loop take a state atom to copy state into every trip through the game loop
- [X] Auto generate form of component state selected
- [X] If something is changed, write the change into the game state
  - This should happen in real time
  - Maybe specify if you want to override the current component state with what's in the inspector ignoring game loop?
- [X] Abstraction for adding functionality at the game loop level?
  - This could be useful for tooling
  - Logging
  - Created middleware to address this
- [X] Remove the checkouts directory when done integrating

* DONE Remove text and styles from mk-text-sprite-state
CLOSED: [2016-02-22 Mon 09:52]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
It should be only needed for the text component so there is separation from state and rendering

* DONE Submit talk for Clojure West <2016-01-27 Wed>
CLOSED: [2016-01-28 Thu 06:10]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:43
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
DEADLINE: <2016-01-28 Thu 12:00>
** Bio:
Alex Kehayias is the CTO at Shareablee and works on biggish data problems to help brands and publishers win the social web. Clojure and Python are his weapons of choice by day and by night. He is an active musician, tech community organizer (ClojureNYC), and helps mentor people learning to code.
** Description:
Alex Kehayias shares the many joys and challenges of building a game engine in a functional style using Clojure and ClojureScript. Over the course of 2+ years, Alex has been actively writing (and rewriting) a functional game engine to find the ideal combination of a quick feedback loop, testing with data, and performance. Join in the sorrows and triumphs of bringing functional programming to web-based game development for fun and zero profit!
** Main Ideas:
1. Game loop as a reduce call
  Structuring the overall game loop as a reduction over a collection of functions into a data structure provides the benefits of functional purity, one way data flow, and easy testing.
2. Entity Component Systems are a perfect match for FP
  Breaking down games following an entity component system popularized by Scott Bilas and the Unity game engine brings the ability to describe complex behaviors with data instead of code which makes for faster iteration to help find the fun.
3. Functional programming comes at a cost
  Performance is always a concern in game programming and the additional usage of functional paradigms means additional overhead, but thankfully can be overcome thanks to the ClojureScript compiler and heavy reference of the core of Clojure.
** Past talks:
- Functional Game Engine Design @ LispNYC: https://vimeo.com/152433890
- Clojure Panel @ ClojureNYC: http://www.meetup.com/Clojure-NYC/events/224632241/
- Storm & Clojure: http://www.meetup.com/Clojure-NYC/events/219336391/
- And a few other workshops as part of the ClojureScript NYC meetup group

* DONE Query-like functionality for state                              :core:
CLOSED: [2016-03-07 Mon 11:46]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:46
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Send a query with what you want and a filter function
- Returns a sequence
- Resolved: components have an option to select component state that will be included in their context

* DONE Protection against overflowing messages
CLOSED: [2016-03-07 Mon 11:47]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:47
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
Throw an error if two many messages are generated. This will prevent avalanches and fail faster so it is easier to diagnose problems.
- [ ] Limit on number of messages in an inbox
- [ ] Limit on number of messages in the event queue
- Ended up adding a system as the last system in the scene that wipes all messages at the end of each loop

* DONE Sprite animation rendering
CLOSED: [2016-03-07 Mon 11:48]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:48
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Fixed timestep animation?
  Each frame ticks the next frame in an animation
- Action list animation?
  This would allow the cancellation of an animation easily. Say a player is attacking and then get's hit halfway through the animation, could cancel the animation and start the hit animation

* DONE Inspect protocol
CLOSED: [2016-03-07 Mon 11:49]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:49
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
All game engine things must be inspectable, returning details about it's current state

* DONE Replace usage of map/filter/for with eager implementations
CLOSED: [2016-03-07 Mon 11:54]
:PROPERTIES:
:ARCHIVE_TIME: 2016-03-07 Mon 11:54
:ARCHIVE_FILE: ~/Dropbox/Private/Clojure/chocolatier/todo.org
:ARCHIVE_CATEGORY: todo
:ARCHIVE_TODO: DONE
:END:
- Use loops instead of for/map as they are more efficient when using transients or arrays as accumulators
